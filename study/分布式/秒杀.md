1. 先登录，调用验证码接口获取验证码
   * 请求参数：用户信息，商品ID
   * 处理：redis的key为userId+“,”+goodId，value为随机数字
   * 返回：验证码随机数字图片
2. 获取秒杀路径接口，注解限制接口访问次数
   * 请求参数：用户信息，商品ID、验证码数字
   * 处理：redis中验证用户对应的验证码数字是否存在并匹配，不存在则返回，redis的key为userId+"_"+goodId，value为md5加密的uuid
   * 返回：md5加密的uuid，即为path
3. 调用秒杀接口
   * 请求参数：用户信息，goodId，@PathVariable("path")修饰path——访问路径
   * 处理：redis中验证path是否存在，不存在则返回，秒杀开始前会把商品库存数量加载到redis，收到请求，Redis预减库存（decr），如果库存不足，直接返回，查询redis来判断用户之前如果已经秒杀到，则直接返回只能购买一件，秒杀消息存入RabbitMQ的秒杀队列，立即返回排队中
4. 异步处理，RabbitMQ监听秒杀队列，请求出消息队列

# 高并发

* 是以秒杀商品为研究背景

* 思路：主要减少数据库访问，使用redis缓存、RabbitMQ消息队列，点击秒杀之前，先输入验证码分散用户请求，设置接口限流防刷
  * 系统初始化时把商品库存数量加载到redis
    * 实现InitializingBean，在其afterPropertiesSet中查询数据库，将商品id、库存存入redis
  * 收到请求，Redis预减库存（decr），如果库存不足，直接返回，否则进入下一步
    * 初始化时可做个HashMap<Long,Boolean>内存标记对应的商品是否卖完，如果卖完，则直接response返回，不用再调用redis
  * 查询redis来判断用户之前如果已经秒杀到，则直接返回只能购买一件
  * 秒杀消息存入RabbitMQ的秒杀队列，立即返回排队中
  * 异步处理
  * RabbitMQ监听秒杀队列，请求出消息队列，
    * 数据库查询商品库存小于等于0，则直接return
    * 查询redis来判断用户之前如果已经秒杀到，则直接return
    * 减库存（sql中要判断商品库存是否大于0，减库存失败（sql返回更新行小于1），则将商品卖完信息存入redis，返回null），生成订单插入数据库，redis中插入用户和商品订单消息，返回订单信息
  * 客户端轮询是否秒杀成功
    * 从redis中查询用户和商品订单消息，
      * 不为null，则秒杀成功，返回商品ID
      * 否则查询redis商品已卖完标记值为true，则返回提示商品已秒杀完
      * 否则提示排队中

* 注意问题
  * 防止用户重复购买：数据库加唯一索引或者redis中做标记
  * 防止商品超卖，数量变为负数：SQL加库存数量判断