# I/O复用

- 文件描述符
  - ==是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表==
  - 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符
- ==进程预先告知内核，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程，这个能力称为I/O复用，是由select和poll两个函数支持==
- 网路应用场合
  - 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用
  - 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用I/O复用
  - 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用
  - 如果一个服务器要处理多个服务或者多个协议，一般要使用I/O复用

## I/O 模型

- 对于一个套接字上的输入操作
  - ==第一阶段，通常涉及等待数据从网络中到达，然后数据被复制到内核中的某个缓冲区==
  - ==第二阶段，把数据从内核缓冲区复制到应用进程缓冲区==

### 阻塞式I/O

- 默认情况下，所有套接字都是阻塞的

  - 进程进行套接字调用时，阻塞于两个阶段（进程被投入睡眠），直到数据从内核复制到应用进程缓冲区或者发生错误才返回
- 当发出一个不能立即完成的套接字调用时，其进程将被投入睡眠，等待相应操作完成。

![image-20190328222934014](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190328222934014.png)

  - 把recvfrom函数视为系统调用，因为正在区分应用进程和内核。不论它如何实现，一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间之后再切换回来
  - 进程调用recvfrom，其系统调用直到数据到达且被复制到应用进程的缓冲区中或者发生错误才返回（常见错误是系统调用被信号中断）
  - 进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。
  - recvfrom成功返回后，应用进程开始处理数据

### 非阻塞式I/O

- 进程把一个套接字设置成非阻塞是在通知内核：

  - 进程持续轮询内核，以查看第一阶段的数据是否准备好（此时进程没被投入睡眠），如果数据准备好，然后进行第二阶段IO操作将数据从内核复制到应用进程缓冲区

  - 当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误

    ![image-20190328223944140](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190328223944140.png)

  - 当一个应用进程对一个非阻塞描述符循环调用recvfrom时，称之为轮询

  - 应用进程持续轮询内核，以查看某个操作是否就绪。

  - 往往耗费大量CPU时间

### I/O复用

* 进程阻塞于select调用（select可以等待多个可读条件就绪），当select返回第一阶段数据准备好可读后，进程再进行第二阶段IO操作将数据从内核复制到应用进程缓冲区

- 可以调用select或poll，阻塞在这两个系统调用中的某一个上，而不是阻塞在真正的I/O系统调用上
- ![image-20190329074627629](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190329074627629.png)
- 阻塞于select调用，等待数据套接字变为可读。当select返回套接字可读这一条件时，调用recvfrom把所读数据复制到应用进程缓冲区
- 由于使用select需要两个而不是单个系统调用，I/O复用还稍有劣势
- ==使用select的优势在于可以等待多个描述符就绪==

### 信号驱动式I/O

* 进行调用信号处理函数后立即返回（没被阻塞），当信号处理函数返回数据准备好后，进程再进行第二阶段IO操作将数据从内核复制到应用进程缓冲区

- 让内核在描述符就绪时发送SIGIO信号通知进程
- ![image-20190329075226800](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190329075226800.png)
- 首先开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是进程没有被阻塞
- 当数据准备好读取时，内核就为该进程产生一个SIGIO信号
- 我们随后既可以在信号处理函数中调用recvfrom读取数据，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据
- 无论如何处理SIGIO信号，这种模型的优势在于等待数据到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据已准备好被读取

### 异步I/O

* 告知内核启动某个操作，并让内核在整个操作完成时通知进程，包括将数据从内核复制到应用进程缓冲区

- 工作机制：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们
- 与信号驱动模型的区别：
  - 信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作
  - 异步I/O模型是由内核通知我们I/O操作何时完成
- ![image-20190329080450691](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190329080450691.png)
- 调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移，并告诉内核当整个操作完成时如何通知我们
- 该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞
- 要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生，这一点不同于信号驱动式I/O模型

## 各种I/O比较

- 阻塞式IO、非阻塞式IO、IO复用、信号驱动式IO
  - 主要区别在第一阶段
  - 第二阶段是一样的
    - 在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用
  - 相反，异步IO模型在这两个阶段都要处理，从而不同于其他四种模型
- 同步IO和异步IO对比
  - 同步IO操作：导致请求进程阻塞，直到IO操作完成
  - 异步IO操作：不导致请求进程阻塞
  - ![image-20190329110250620](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190329110250620.png)
  - 阻塞式IO、非阻塞式IO、IO复用、信号驱动式IO都是同步型I/O模型，因为其中真正的IO操作（recvfrom）将阻塞进程





