# TCP/IP

* `Transmission Control Protocol`，即 传输控制协议

* ==TCP是一种面向连接的、可靠的、基于字节流、全双工通信的【传输层】通信协议==

  * 基于`TCP`的应用层协议有`HTTP`、`SMTP`、`FTP`、`Telnet` 和 `POP3`
  * 全双工：双方不仅都能发信息，而且能够同时发送
  * 半双工：双方都能发信息，但同一时间则只能一方发信息
  * 单工：一方只能发信息，另一方则只能收信息，通信是单向的

* `TCP` / `IP`体系结构：含了一系列构成互联网基础的网络协议，是`Internet`的核心协议 & 被广泛应用于局域网 和 广域网

* OSI体系结构（7层）：

  * 物理层-链路层-网络层 -传输层-会话层-表示层-应用层

* TCP/IP体系结构（4层）：

  * 网络接口层-网际层（IP）-传输层（TCP/UDP）-应用层（HTTP）

* 五层体系结构

  * 物理层-链路层-网络层-传输层-应用层

* ==TCP /IP 通信协议（传输控制协议/互联⽹协议），在通信的两端各建立⼀个Socket，从而在通信的两端之间形成网络虚拟链路用于发送和接收数据==

  * IP 协议只保证计算机能发送和接收分组数据，但还不能解决数据分组在传输过程中可能出现的问题 

    * IP地址，用于唯一地标识⽹络中的一个通信实体
    * 可以有多个通信程序同时提供网络服务，端口0~65535

* TCP协议提供可靠并且无差错(重发机制，没收到确认回复则重发)的通信服务

  * 用来校验和检测数据在传输过程中是否有误

* Java使用Socket对象代表两端的通信端口，并通过Socket产生IO流来进行网络通信

  * ServerSocket创建TCP服务器端

    * 接收其他通信实体连接请求，其对象⽤于监听来自客户端的Socket连接，如果没有，则一直处于等待状态

    * 服务器端应该为每个Socket单独启动一个线程，每个线程负责与一个客户端进⾏通信

      ```java
      ServerSocket ss = new ServerSocket(30000); //没有指定IP则默认本机IP
      while(true) {
      //每当接收到客户端Socket的请求时，服务器端也对应产生⼀个Socket 
          Socket s = ss.accept();
      	...
      }
      //连接建⽴后，通过使用 I/O 流在进行通信，每一个socket都有⼀个输出流和⼀个输⼊流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流
      //TCP 是⼀个双向的通信协议，因此数据可以通过两个数据流在同一时间发送
      ```

  * 客户端可以使用Socket的构造器来连接到指定服务器

    * 客户端需要和服务器端保持长时间通信

      ```java
      //连接到指定服务器，让服务器端的ServerSocket的accept()向下执行 
      //服务器端和客户端就产生一对相互连接的Socket
      Socket s = new Socket("IP",端口);
      s.setSoTimeout(1000); //设置超时 //程序⽆需区分服务器端、客户端，⽽是通过各自的Socket进行通信 
      getInputStream()
      getOutputStream() //程序从Socket中取出数据，向Socket中输出数据
      ```

  * URI：统一资源标志符，不能⽤于定位任何资源，唯一作⽤就是解析

  * URL：统一资源定位器，指向互联网“资源”的指针，URI的特例

    ```java
    URL url = new URL(path); 
    openConnection()//代表了与URL所引用的远程对象的连接
    openStream() //打开与此URL的连接，并返回⼀个用于读取该URL资源的InputStream
    ```

  * IP+端⼝

  * InnetAddress代表IP地址，没有构造器，静态方法获取实例

  * URL地址中包含非西欧字符的字符串时

    - URLDecoder.decode(MIME字符串, "utf-8"); ——String
    - URLEncoder.encode(String, "GBK"); ——MIME字符串

## 三次握手

tcp，三次传输，以确保任何一次失败的连接都不会长时间占用资源

1. 建立连接时，客户端向服务端发送连接请求（同步标志位SYN=1，随机选择一个起始序号seq=x），等待服务器确认，客户端进入同步已发送状态
2. 服务端接收并确认消息，若同意建立连接，则向客户端发送连接确认消息（同步标志位SYN=1，确认标记位ACK=1，随机选择一个起始序号seq=y，确认号字段ack=x+1），服务器进入同步已接收状态
3. 客户端收到服务端的消息，向服务端发送确认收到消息（确认标记位ACK=1，序号seq=x+1，确认号字段ack=y+1），该消息发送完毕后，TCP连接成功，完成三次握手

## 四次挥手

1. 客户端向服务端发送连接释放消息，客户端进入终止等待状态
2. 服务端收到客户端发送释放连接消息后，向客户端发送连接释放确认消息
3. 若服务端已无要向客户端发送数据，则发出释放连接消息
4. 客户端接收到连接释放消息后，则向服务端发送连接释放确认消息

* 等待服务端的数据都发送完

## 滑动窗口机制

* 无差错传输
* ==是传输层进行流控的一种措施，接收方通过告知发送方自己的窗口大小，来控制发送方的发送速度，从而达到防止发送方发送速度过快而导致数据被覆盖==
* ACK包含两个非常重要的信息：
  * ==一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据==。
  * ==二是当前的窗口大小m==
  * 如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，这就是滑动窗口控制流量的基本原理
* 发送端：
  * 每收到一个确认帧，发送窗口就向前滑动一个帧的距离
  * 当窗口内的帧全部是已发送但未收到确认的，发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送
* 接收端：
  * 当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃

## 和UDP的区别

* ==UDP协议：面向非连接（直接发送）、不可靠、一次只传送少量数据的用户数据报协议==
  * 应用在实时性很强的应用场景，⽐如网络游戏、视频会议等，快速更具独特性
* TCP协议：面向连接、可靠、有序的字节流传输，传输⼤小无限制，但是差错控制开销⼤。对应的协议（FTP/SMTP/HTTP）
* UDP协议：面向非连接、不可靠、无序的数据报文段（每一个都是单独的传输单元）传输，传输⼤小限制在64kb以下，差错控制开销小。对应的协议（DNS）

# Socket

- ==socket即套接字，本质是一个封装了 TCP / IP协议族的编程接口(API)，可做网络通信开发，是对TCP/IP的封装==
  - HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力
- 一个 `Socket` 实例唯一代表一个主机上的一个应用程序的通信链路
- `Socket`可基于`TCP`或者`UDP`协议，但TCP更加常用
- 服务器
  - ==创建一个ServerSocket实例，监听指定端口，阻塞等待客户端的连接请求，完成三次握手，返回服务端Socket实例，然后服务端和客户端可进行通信==
- 客户端
  - ==创建一个Socket实例，分配本地端口，通过远程地址、端口号连接远程服务端，完成三次握手，Socket实例创建完成==
- Socket 与 Http 对比
  - `Socket`属于传输层，因为 `TCP / IP`协议属于传输层，**解决的是数据如何在网络中传输的问题**
  - `HTTP`协议属于应用层，**解决的是如何包装数据**
  - `Http`：采用 **请求—响应** 方式，即建立网络连接后，当客户端向服务器发送请求后，服务器端才能向客户端返回数据
  - `Socket`： **服务器可主动发送数据** ，即建立网络连接后，服务器可主动发送消息给客户端

* 在浏览器地址栏输入URL按下回车后的经历的流程

  - ==DNS解析（域名到ip的寻址过程）-TCP连接-发送HTTP请求-服务器处理请求并返回HTTP报文-浏览器解析渲染页面-连接结束==

# HTTP

* 使得Web服务器与浏览器之间可以通过互联网或者企业内部网来交换数据
* ==是基于TCP/IP协议的【应用层】协议。它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式==，是互联网信息交互中最常用的协议，用GET/POST/DELETE/PUT来实现RESTFUL
* `HTTP`协议采用 请求 / 响应 的工作方式
* 特点
  1. ==简单快速。只需要传【请求方法】与【资源路径】就能确定资源==
  2. ==灵活，传输【任意类型】的数据==
  3. ==无连接，一般一次连接只处理一个请求，结束后主动释放连接，但可以使用keep-alive来复用相同的TCP连接发送多个请求==
  4. ==无状态，客户端向服务器发送HTTP请求之后，服务器会返回数据，但不会记录任何信息。所以Cookie、Session产生了==
* HTTP请求结构
  - HTTP请求报文
  - 请求行
    - ==请求方法 空格 URL 空格 协议版本 回车符换行符==
  - 请求头部
    - 头部字段名：值 回车符 换行符
    - 头部字段名：值 回车符 换行符
  - 回车符 换行符
  - 请求正文
* HTTP响应结构
  - HTTP响应报文
  - 状态行
    - ==协议版本 空格 状态码 空格 状态描述 回车符 换行符==
  - 响应头部
    - 头部字段名：值 回车符 换行符
    - 头部字段名：值 回车符 换行符
  - 回车符 换行符
  - 响应正文
* GET请求和POST请求的区别
  - Http报文层面：GET将请求信息放在URL，POST放在报文体
  - 数据库层面：GET符合幂等性和安全性，POST不符合
  - 其他层面：GET可以被缓存、被存储，而POST不行
* Cookie
  - 简介
    - 是由服务器发送给客户端的特殊信息，以文本的形式存放在客户端
    - 客户端再次请求的时候，会把Cookie回发
    - 服务器接收到后，会解析Cookie生成与客户端相对应的内容
  - Cookie的设置以及发送过程
    - 客户端发送Http Request给Web服务器
    - Web服务器返回Http Response 和set-Cookie:JSESESSION=xxx给客户端
    - 客户端发送Http Request 和Cookie:JSESESSION=xxx给服务器
    - 服务器返回Http Response
* Session
  - 实现方式
    - 使用Cookie来实现
    - 使用URL回写来实现
* Cookie和Session的区别
  - Cookie数据存放在客户的浏览器上，Session数据放在服务器上
  - Session相对于Cookie更安全
  - 若考虑减轻服务器负担，应当使用Cookie

# HTTPS

- 经由HTTP进行通信，但利用SSL/TLS来加密数据包
- 是一个确保数据在浏览器与服务器之间传输安全的协议
- HTTPS 由两部分组成：HTTP协议+SSL（TLS）协议，也就是在HTTP上又加了一层处理加密信息的模块，传输的数据都是加密后的数据
  - SSL，传输层安全性协议，目的是为互联网通信提供安全及数据完整性保障
    - 客户端向服务器端索要并验证公钥
    - 双方用协商生成的"对话密钥"进行加密通信
- 原理：HTTPS在传输数据之前需要客户端与服务器进行一次握手，在握手过程中将确立双方加密传输数据的密码信息
- HTTP - SSL or TLS - TCP - IP
- SSL安全套阶层，是操作系统对外的API，SSL3.0后更名为TLS，采用身份验证和数据加密保证网络通信的安全和数据的完整性
- 加密方式
  - 对称加密：加密和解密都使用同一个密钥
  - 非对称加密：加密使用的密钥和解密使用的密钥是不相同的
  - 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆
  - 数字签名：证明某个消息或者文件是某人发出/认同的
- HTTPS数据传输流程
  - ==浏览器将支持的加密算法信息发送给服务器==
  - ==服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器==
  - ==浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器==
  - ==服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器==
  - ==浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据==
- HTTP和HTTPS的区别
  - HTTPS需要到CA申请证书，HTTP不需要
  - ==HTTPS密文传输，HTTP明文传输==
  - ==连接方式不同，HTTPS默认使用443端口，HTTP使用80端口==
  - ==HTTPS=HTTP + 加密 + 认证 + 完整性保护，较HTTP安全==
- HTTPS真的很安全吗
  - 那倒未必
    - 浏览器默认填充http://，请求需要进行跳转，有被劫持的风险
    - 可以使用HSTS（HTTP Strict Transport Security）优化

# 转发和重定向

* 转发
  * `request.getRequestDispacther()`
  * `RequestDispatcher`类的`forward()`方法
  * A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A
  * 整个过程是一个请求，一个响应，地址不会改变
* 重定向
  * `response.sendRedirect()`
  * A找B借钱，B说没有，让A去找C借
  * 两个请求，两个响应，地址会变成重定向后向服务器请求的地址

# Reactor模式

* 事件驱动的，有一个或多个并发输入源，service handler会同步（阻塞）的将输入请求事件根据其事件类型通过多路复用分发给相应的request handler去处理
  * 有点类似生产者消费者模式，不过没有队列来做缓冲

# 零拷贝

* ==直接把消息从Linux 文件系统缓存里发送到网络通道，而不需经过任何中间缓冲区，避免了字节复制，也不需要管理内存缓冲区，从而获得更好的性能==

- 服务器先从硬盘读取数据到内存，然后把内存中的数据原封不动的通过`socket` 发送出去

  1. 操作系统将数据从磁盘读入到内核空间的页缓存
  2. 应用程序将数据从内核空间读入到用户空间缓存中
  3. 应用程序将数据写回到内核空间的`socket` 缓存中
  4. 操作系统将数据从`socket` 缓冲区复制到网卡缓冲区，以便将数据经网络发出

  - 这个过程涉及到 `4` 次上下文切换以及 `4` 次数据复制，并且有两次复制操作是由`CPU` 完成
  - 但是这个过程中，数据完全没有进行变化，仅仅是从磁盘复制到网卡缓冲区

- 通过“零拷贝”技术，可去掉没必要的数据复制操作，同时也减少上下文切换次数

  - 现代的 `unix` 操作系统提供一个优化的代码路径
    - 用于将数据从页缓存传输到 `socket`
    - 在 `Linux` 中，是通过 `sendfile` 系统调用来完成的
      - 只用将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中（发送给不同的订阅者时，都可以使用同一个页面缓存），避免了重复复制操作
    - Java 提供了访问这个系统调用的法：`FileChannel.transferTo` API

# WebSocket

* 是HTML5新增的协议
* 目的是让客户端和服务端可以互相主动发送消息

1. ==支持长连接。WebSocket是一个新协议，可以看成是在HTTP协议上打上一个【支持长连接】的补丁==
2. ==支持服务器推送。HTTP协议是接收请求然后响应（请求－应答机制限制了TCP/IP全双工通信）。而WebSocket可以让服务器主动推送==
3. ==基于HTTP。WebSocket是基于HTTP协议，借用HTTP协议完成一部分握手==

* 如何建立连接（在Http协议基础之上进行升级握手）
  * 在从标准的HTTP或者HTTPS协议切换到WebSocket时，将会使用一种称为升级握手的机制
    * 客户端发送一个HTTP请求，请求地址以ws://开头，请求头中包含连接升级和升级类型为WebSocket的信息，标识这个连接的信息及WebSocket的版本
    * 服务端接收升级则响应连接升级及升级类型为WebSocket的信息、协议被更改的101响应代码、标识这个连接的信息
    * WebSocket连接建立成功，客户端和服务端都可主动发送消息（二进制或文本）

#  REST/RESTful

* ==是一种软件架构风格，不是一个标准，但大部分RESTful Web服务实现会使用HTTP、URI、JSON和XML等各种协议和标准==
* 目的是便于不同软件/程序在网络中互相传递信息
* 要点和标准：
  * ==资源是由URI来指定==
  * ==通过操作资源的表现形式（Content-Type）来操作资源，资源的表现形式则是XML、HTML或者JSON==
  * ==对资源的操作包括创建、获取、修改和删除，这些操作正好对应HTTP协议提供的POST、GET、PUT和DELETE方法==
    * PUT和DELETE方法是幂等方法。GET方法是安全方法（不会对服务器端有修改，因此当然也是幂等的）
* 应用场景
  - REST适用于异构系统之间调用，如Java调C等
  - REST适用于网关调用，内部调用用RPC比较好
  - REST的HTTP请求头比较大
  - REST是文本协议，需要序列化/反序列化——成本高
* 优点

  * ==不需要额外的资源发现机制==
  * 可更高效利用缓存来提高响应速度
  * ==浏览器即可作为客户端，简化软件需求==
  * ==相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小==
  * ==通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性==
  * 在软件技术演进中的长期的兼容性更好
* ==REST架构风格最重要的架构约束有6个==
  * （客户-服务器）C/S架构
    * 通信只能由客户端单方面发起，表现为请求-响应的形式；
    * 客户端与服务器分离模式，任何一个客户端与服务器都是可替换的
  * （无状态）
    * 通信的会话状态应该全部由客户端负责维护
  * （缓存）
    * 响应内容可以在通信链的某处被缓存，以改善网络效率
  * （统一接口）
    * 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性
    * 每个资源都可以通过URI访问到；通过客户端可以修改原资源的状态；客户端根据返回信息可以知道如何处理；处理以超媒体为基础的状态变化
  * （分层系统）
    * 每个组件只能“看到”与其交互的紧邻层，将架构分解为若干等级的层
  * （按需代码）
    * 支持通过下载并执行一些代码，如JavaScript，对客户端的功能进行扩展
* 应用于Web服务
  - 匹配REST设计风格的Web API称为**RESTful API**。它从以下三个方面资源进行定义：
    - 直观简短的资源地址：URI
    - 传输的资源：Web服务接受与返回的互联网媒体类型，如JSON、XML等
    - 对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT或DELETE）
  - **HTTP请求方法在RESTful API中的典型应用**
    - **GET**，可获取指定资源详细信息，格式可以是XML、JSON
      - 一个简单的网络商店应用，列举所有商品`GET http://www.store.com/products`
      - 呈现某一件商品`GET http://www.store.com/products/12345`
    - **PUT**，**替换/创建**指定的资源
    - **POST**，某个资源组下**创建/追加**一个新的元素
      - 下单购买，`POST http://www.store.com/orders`
    - **DELETE**，删除资源
    - PUT和DELETE方法是幂等方法。GET方法是安全方法（不会对服务器端有修改，因此当然也是幂等的）
* ==使用REST和使用MVC是类似的，不同的是，提供REST的Controller处理函数最后不调用`render()`去渲染模板，而是把结果直接用JSON序列化返回给客户端==

# 阻塞IO和非阻塞IO

* TCP协议：对于TCP通信来说，每个TCP的socket的内核里面都会有发送缓冲区和接收缓冲区
* 《TCP/IP详解》
* 接收端的接收缓冲区会把数据存到内核，如果应用进程一直没有调用到socket里面的read方法进行读取，那么这个数据会一直被缓存到缓存区里面，直到应用程序通过read去读取
  - 不管进程是否读取socket，对发送端来说，它的数据都会经过内核接收并且缓存到socket的内存缓冲区，read把内核接收的缓冲区的数据赋值到应用层用户的buffer里面（从内核空间复制到应用空间）
  - 进程调用socket的send来发送数据的时候，一般情况下是把数据从应用层复制到socket的 内核发送缓冲区。send是异步的，send返回时，数据不一定发送到了接收缓冲区。
  - 接收缓冲区的数据如果一直没有被读取，直到满了过后会通知TCP的对端关闭窗口，保证TCP接收端的接收缓冲区数据不会被移除，这样就保证 了消息的传输性（可能是利用滑动窗口协议来做的）——限流
* 阻塞IO
  - （发送消息时对方要准备好，否则处于阻塞，接收端也一样）
  - （浪费资源，任何一个过程比较慢的话，会导致整个过程慢）
  - 对于读取socket数据过程而言，如果接收缓冲数据为空的话，socket调用read的方法后，线程会处于阻塞状态，直到有数据到接收缓冲区
  - 对于写入socket发送缓冲区，如果待发送的缓冲区的数据长度大于发送缓冲区本身空余的长度，这时候会阻塞到wait方法上，必须要等到发送缓冲区的报文全部发送到网络上以后，才能继续发送下一个报文
* 非阻塞IO
  - 用来解决IO线程和Socket解耦的问题，引入一个事件机制来达到解耦 ，可以认为底层存在一个IO线程调度，它不断的扫描每一个socket缓冲区，当发现写（发送）缓冲区为空，会产生一个socket可写事件通知发送端的一个线程去写数据，如果一次写不完，会等到下一次；反之，对于接受端来说，如果发现接收端的缓冲区可读时，它会发送一个事件，如果不能读，就不会处于阻塞状态，就会去其他事情
  - 事件机制涉其实就是IO多路复用的一个模型，在Linux里可以使用select、inpo等方式。当线程准备去读接收缓冲区时，发现接收缓冲区还没准备好，那不会等待，会把线程放入 select这样的调度系统里，select系统里有N个这样的线程，当可读的时候，会发送一个事件通知select选择一个事件去执行，这就完美地利用事件机制来达到非阻塞IO的一个情况，充分利用了资源
* BIO
  - 同步阻塞
  - 同步：是否要亲自去监听操作，不断进行关注，是否已经完成对应的操作呢
  - 阻塞：IO操作如果没有完成，在单线程的情况下，当前线程一定会等待在这边，没有办法进行其他操作
  - 每来一个客户端的Socket连接，都会针对这个Socket创建出一个线程，为IO操作进行处理；多线程的方式解决了多个客户端同时进行连接的情况
  - 问题来了，针对多个客户端连接，服务端的线程数量肯定会增加的
  - 改良方案：在IO操作的时候进行创建线程进行处理。
* NIO
  - 同步非阻塞IO（同步：要自己不断的询问是否已经完成；非阻塞：IO 操作不需要再进行阻塞在那边，直接返回）
* AIO：异步非阻塞
  - 异步：用户发出了IO操作之后，这时候就不关心，委托给操作系统进行完成，当操作系统完成这个IO操作之后，再告诉自己就OK
* 同步(Synchronization)和异步(Asynchronous)的方式
  - 同步和异步都是基于应用程序和操作系统处理 IO 事件所采用的方式
  - 同步：是应用程序要直接参与 IO 读写的操作
    - 同步方式在处理 IO 事件的时候，必须阻塞在某个方法上面等待我们的 IO 事件完成(阻塞 IO 事件或者通过轮询 IO 事件的方式)
    - 同步:1)阻塞到 IO 事件，阻塞到 read 或则 write。这个时候我们就完全不能做自己的事情。让读写方法加入到线程里面，然后阻塞线程来实现，对线程的性能开销比较大
  - 异步：所有的 IO 读写交给操作系统去处理，应用程序只需要等待通知
    - 所有的 IO 读写都交给了操作系统。
    - 这个时候，我们可以去做其他的事情，并不需要去完成真正的 IO 操作，当操作完成 IO 后，会给我们的应用程序一个通知



