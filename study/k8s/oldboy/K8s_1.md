```shell
# 页面
http://harbor.od.com/
http://traefik.od.com/
https://dashboard.od.com/
http://k8s-yaml.od.com/
http://jenkins.od.com/
http://dubbo-monitor.od.com/
http://config.od.com/
http://portal.od.com/
```

# 开机启动

```shell
# 1. 192.168.0.200 运维主机上启动harbor
# 重新启动harbor
cd /opt/harbor
docker-compose up -d
# 验证是否启动成功
curl harbor.od.com

# 2. 192.168.0.21、192.168.0.22启动
/root/ipvs.sh 
# 验证
lsmod | grep ip_vs

# 11、12、21
# zk
[root@hdss7-11 ~]# /opt/zookeeper/bin/zkServer.sh start
[root@hdss7-12 ~]# /opt/zookeeper/bin/zkServer.sh start
[root@hdss7-21 ~]# /opt/zookeeper/bin/zkServer.sh start
[root@hdss7-11 ~]# /opt/zookeeper/bin/zkServer.sh status


# 日志
## etcd
tail -fn 200 /data/logs/etcd-server/etcd.stdout.log
[root@hdss7-12 logs]# netstat -luntp|grep etcd
tcp        0      0 192.168.0.12:2379     0.0.0.0:*               LISTEN      19395/./etcd        
tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      19395/./etcd        
tcp        0      0 192.168.0.12:2380     0.0.0.0:*               LISTEN      19395/./etcd  
# 任意节点检测etcd集群健康状态
[root@worker2 etcd]# ./etcdctl cluster-health
[root@worker2 etcd]# ./etcdctl member list

## apiserver
tail -fn 200 /data/logs/kubernetes/kube-apiserver/apiserver.stdout.log
[root@worker2 bin]# supervisorctl status
etcd-server-7-21                 RUNNING   pid 2723, uptime 2:04:39
kube-apiserver-7-21              RUNNING   pid 2945, uptime 0:03:14
[root@hdss7-21 bin]# netstat -luntp | grep kube-api
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      27303/./kube-apiser 
tcp6       0      0 :::6443                 :::*                    LISTEN      27303/./kube-apiser 

## L4反向代理
tail -fn 200 /var/log/messages
[root@hdss7-11 ~]# netstat -luntp | grep 7443
tcp        0      0 0.0.0.0:7443            0.0.0.0:*               LISTEN      22071/nginx: master 
ip a  # 查看虚拟IP

## controller-manager
tail -fn 200 /data/logs/kubernetes/kube-controller-manager/controller.stdout.log

## kube-scheduler
tail -fn 200 /data/logs/kubernetes/kube-scheduler/scheduler.stdout.log
[root@hdss7-21 bin]# kubectl get cs
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-2               Healthy   {"health": "true"}   
etcd-0               Healthy   {"health": "true"}   
etcd-1               Healthy   {"health": "true"}

## kubelet
tail -fn 200 /data/logs/kubernetes/kube-kubelet/kubelet.stdout.log 
# 正常情况
[root@hdss7-21 cert]# kubectl get nodes
NAME                STATUS   ROLES    AGE     VERSION
hdss7-21.host.com   Ready    <none>   15h     v1.15.2
hdss7-22.host.com   Ready    <none>   8m51s   v1.15.2

## kube-proxy
tail -fn 200 /data/logs/kubernetes/kube-proxy/proxy.stdout.log
[root@hdss7-22 ~]# netstat -luntp |grep kube-proxy
tcp        0      0 127.0.0.1:10249         0.0.0.0:*               LISTEN      7310/./kube-proxy   
tcp6       0      0 :::10256                :::*                    LISTEN      7310/./kube-proxy  
# 查看日志
tail -fn 200 /data/logs/kubernetes/kube-proxy/proxy.stdout.log

# 查看ipvs是否生效
[root@hdss7-21 ~]# yum install -y ipvsadm	# 只安装，不启动
[root@hdss7-21 ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.0.1:443 nq
  -> 10.4.7.21:6443          Masq    1      0          0         
  -> 10.4.7.22:6443          Masq    1      0          0  
```

* 使用Docker容器化封装应用程序的缺点
  * 单机使用，无法有效集群
  * 随着容器数量的上升，管理成本攀升
  * 没有有效的容灾/自愈机制
  * 没有预设编排模版，无法实现快速、大规模容器调度
  * 没有统一的配置管理中心
  * 没有容器生命周期的管理工具
  * 没有图形化运维管理工具

# k8s快速入门

## 1.15.2

## 优势

* 自动装箱，水平扩展，自我修复
* 服务发现和负载均衡
* 自动发布（默认滚动发布模式）和回滚
* 集中化配置管理和密钥管理
* 存储编排
* 任务批处理运行

## 四组基本概念

* Pod/Pod控制器
  * Pod
  * 是k8s里能够被运行的最小的逻辑单元（原子单元）
    * 1个Pod里面可以运行多个容器，它们共享UTS+NET+IPC名称空间
  * 一个Pod里运行多个容器，又叫：边车（SideCar模式）
  * Pod控制器
    * Pod控制器是Pod启动的一种模版，用来保证在k8s里启动的Pod应始终按照人们的预期运行（副本数、生命周期、健康状态检查...）
    * k8s内提供了众多的Pod控制器，常用的有：
      * **Deployment**
      * **DaemonSet**
      * ReplicaSet
      * StatefulSet
      * Job
      * Cronjob
* Name/Namespace
  * Name
    * 由于k8s内部，使用“资源”来定义每一种逻辑概念（功能），故每种“资源”，都应该有自己的名称
    * “资源”有api版本（apiVersion）类别（kind）、元数据（metadata）、定义清单（spec）、状态（status）等配置信息
    * “名称”通常定义在“资源”的“元数据”信息里
  * Namespace
    * 随着项目增多、人员增加、集群规模的扩大，需要一种能够隔离k8s内各种“资源”的方法，这就是名称空间
    * 名称空间可以理解为k8s内部的虚拟集群组
    * 不同名称空间内的“资源”，名称可以相同，相同名称空间内的同种“资源”，“名称”不能相同
    * 合理的使用k8s的名称空间，使得集群管理员能够更好的对交付到k8s里的服务进行分类管理和浏览
    * k8s里默认存在的名称空间有：default、kube-system、kube-public
    * 查询k8s里特定“资源”要带上相应的名称空间
* Label/Label选择器
  * Label
    * 标签是k8s特色的管理方式，便于分类管理资源对象
    * 一个标签可以对应多个资源，一个资源也可以有多个标签
    * 一个资源拥有多个标签，可以实现不同维度的管理
    * 标签的组成：key=value
    * 与标签类似的，还有一种“注解”（annotations）
  * Label选择器
    * 给资源打上标签后，可以使用标签选择器过滤指定的标签
    * 标签选择器目前有两个：基于等值关系（等于、不等于）和基于集合关系（属于、不属于、存在）
    * 许多资源支持内嵌标签选择器字段
      * matchLabels
      * matchExpressions
* service/Ingress
    * Service
        * 在k8s的世界里，虽然每个Pod都会被分配一个单独的IP地址，但这个IP地址会随着Pod的销毁而消失
        * Service（服务）就是用来解决这个问题的核心概念
        * 一个Service可以看作一组提供相同服务的Pod的对外访问接口
        * Service作用于那些Pod是通过标签选择器来定义的
    * Ingress
      * Ingress是k8s集群里工作在OSI网络参考模型下，第7层的应用，对外暴露的接口
      * Service只能进行L4流量调度，表现形式是ip + port
      * Ingerss则可以调度不同业务域、不同URL访问路径的业务流量

## 核心组件

* 配置存储中心——etcd服务

* 主控（master）节点

  * kube-apiserver服务
    * 提供了集群管理的REST API接口（包括鉴权、数据校验及集群状态变更）
    * 负责其他模块之间的数据交互，承担通信枢纽功能
    * 是资源配额控制的入口
    * 提供完备的集群安全机制
  * kube-controller-manager服务
    * 由一系列控制器组成，通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态
    * Node Controller
    * Deployment Controller
    * Service Controller
    * Volume Controller 
    * Endpoint Controller
    * Garbage Controller
    * Namespace Controller
    * Job Controller
    * Resource quta Controller
    * ...
  * kube-scheduler服务
    * 主要功能是接收调度pod到适合的运算节点上
    * 预算策略（predict）
    * 优选策略（priorities）

* 运算（node）节点

  * kube-kubelet服务

    * 简单的说，kubelet的主要功能就是定时从某个地方获取节点上pod的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态
    * 定时汇报当前节点的状态给apiserver，以供调度的时候使用
    * 镜像和容器的清理工作，保证节点上镜像不会占满磁盘空间，退出的容器不会占用太多资源

  * kube-proxy服务

    * 是K8S在每个节点上运行网络代理，service资源的载体
    * 建立了pod网络和集群网络的关系（clusterip——>podip）
    * 常用三种流量调度模式
      * Userspace（废弃）
      * Iptables（濒临废弃）
      * Ipvs（推荐）
    * 负责建立和删除包括更新调度规则、通知apiserver自己的更新，或者从apiserver那里获取其他kube-proxy的调度规则变化来更新自己的

    ![image-20200809144459056](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200809144459056.png)

    ![image-20200809144808938](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200809144808938.png)

## CLI客户端

* kubectl

## 核心附件

* CNI网络插件——flannel/calico
* 服务发现插件——coredns
* 服务暴露用插件——traefik
* GUI管理插件——Dashboard

# 实验部署集群架构详解

![image-20200809145022191](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200809145022191.png)

# ==直接上传文件夹内相应配置文件==

# 部署k8s集群前准备工作

* Minikube 单节点微型K8S（仅供学习、预览使用）
* **二进制安装部署（生产首选，新手推荐）**
  * 2G2核NAT
* 使用kubeadmin进行部署，K8S的部署工具，跑在K8S里（相对简单，熟手推荐）

## 环境准备（二进制）

* 准备5台2c/2g/50g虚拟机，使用10.4.7.0/24网络
* 预装CentOS7.6操作系统，做好基础优化
* 安装部署bind9，部署自建DNS系统
* 准备自签证书环境
* 安装部署Docker环境，部署Harbor私有仓库

## 三种网络规划

```shell
Service网络：10.254.0.0/16
node节点网络：192.168.0.1
pod网络：172.7.0.0/16
```

## 虚拟机基础优化

![image-20200809151538759](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200809151538759.png)

```shell
hostnamectl set-hostname HDSS7-11.host.com  # 192.168.0.11
hostnamectl set-hostname HDSS7-12.host.com  # 192.168.0.12
hostnamectl set-hostname HDSS7-21.host.com  # 192.168.0.21
hostnamectl set-hostname HDSS7-22.host.com  # 192.168.0.22
hostnamectl set-hostname HDSS7-200.host.com # 192.168.0.200

vi /etc/selinux/config
将SELINUX=enforcing改为SELINUX=disabled
设置后需要重启才能生效
# 关闭防火墙
systemctl stop firewalld
systemctl disable firewalld
```

```shell
# 调整yum源：
# 安装epel-release
# yum install -y epel-release
curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
# 安装工具
yum install wget net-tools telnet tree nmap sysstat lrzsz dos2unix bind-utils -y
# 查看内核版本，运行docker需要3.8以上
uname -a
```

## 自建DNS系统

* 在hdss7-11安装Bind上

```shell
# hdss7-11上 (master)
yum install bind -y
rpm -qa bind

# 配置bind
[root@hdss7-11 ~]# vi /etc/named.conf			# BIND进程的工作属性，区域的定义
13         listen-on port 53 { 192.168.0.11; };	# 监听本机IP
14         listen-on-v6 port 53 { ::1; };		# 删除，不监听IPV6
20         allow-query     { any; };			# 允许所有主机查看
21         forwarders      { 192.168.0.2; };		# 办公网上一级的DNS 
33         recursion yes;				# dns采用递归的查询
35         dnssec-enable no;				# 关闭，节省资源（生产可能不需要关闭）
36         dnssec-validation no;			# 关闭，节省资源，不做互联网认证	
	
# 检查配置	
检查配置文件是否正确
[root@hdss7-11 ~]# named-checkconf
[root@hdss7-11 ~]# echo $?
0

# 配置区域配置文件
[root@hdss7-11 ~]# vi /etc/named.rfc1912.zones
# 最后添加
zone "host.com" IN {
        type  master;
        file  "host.com.zone";
        allow-update { 192.168.0.11; };
};

zone "od.com" IN {
        type  master;
        file  "od.com.zone";
        allow-update { 192.168.0.11; };
};


# 配置区域数据文件
[root@hdss7-11 ~]# vi /var/named/host.com.zone
$ORIGIN host.com.
$TTL 600	; 10 minutes						# 过期时间2019.12.09+01序号				
@       IN SOA	dns.host.com. dnsadmin.host.com. (			# 区域授权文件的开始，OSA记录，dnsadmin.host.com为邮箱
				2019120901 ; serial			# 安装的当天时间
				10800      ; refresh (3 hours)
				900        ; retry (15 minutes)
				604800     ; expire (1 week)
				86400      ; minimum (1 day)
				)
			NS   dns.host.com.				# NS记录
$TTL 60	; 1 minute
dns                A    192.168.0.11					# A记录
HDSS7-11           A    192.168.0.11
HDSS7-12           A    192.168.0.12
HDSS7-21           A    192.168.0.21
HDSS7-22           A    192.168.0.22
HDSS7-200          A    192.168.0.200

# 配置业务域数据文件
[root@hdss7-11 ~]# vi /var/named/od.com.zone
$ORIGIN od.com.
$TTL 600	; 10 minutes
@   		IN SOA	dns.od.com. dnsadmin.od.com. (
				2019120901 ; serial
				10800      ; refresh (3 hours)
				900        ; retry (15 minutes)
				604800     ; expire (1 week)
				86400      ; minimum (1 day)
				)
				NS   dns.od.com.
$TTL 60	; 1 minute
dns                A    192.168.0.11

# 检查配置文件是否正确
[root@hdss7-11 ~]# named-checkconf
[root@hdss7-11 ~]# echo $?
0

# 检测区域数据文件
[root@hdss7-11 named]# named-checkzone "host.com" /var/named/host.com.zone
zone host.com/IN: loaded serial 2019121001
OK
[root@hdss7-11 named]# named-checkzone "od.com" /var/named/od.com.zone
zone od.com/IN: loaded serial 2019120901
OK

# 暂时不用
# 更改文件的属组，权限
[root@hdss7-11 named]# chown root:named /var/named/host.com.zone 
[root@hdss7-11 named]# chown root:named /var/named/od.com.zone
[root@hdss7-11 named]# chmod 640 /var/named/host.com.zone 
[root@hdss7-11 named]# chmod 640 /var/named/od.com.zone

# 启动named
[root@hdss7-11 named]# systemctl restart named
[root@hdss7-11 named]# systemctl enable named

# 查看启动端口
[root@hdss7-11 ~]# netstat -luntp | grep 53
tcp        0      0 192.168.0.11:53         0.0.0.0:*               LISTEN      1533/named
tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      1533/named
tcp6       0      0 ::1:953                 :::*                    LISTEN      1533/named
udp        0      0 192.168.0.11:53         0.0.0.0:*                           1533/named

# 验证解析
[root@hdss7-11 named]# dig -t A hdss7-21.host.com @192.168.0.11 +short
192.168.0.21
[root@hdss7-11 named]# dig -t A hdss7-200.host.com @192.168.0.11 +short 
192.168.0.200
```

```shell
# 更改客户端dns
[root@hdss7-11 named]# vi /etc/sysconfig/network-scripts/ifcfg-ens33
DNS1=192.168.0.11
[root@hdss7-11 named]# systemctl restart network
[root@hdss7-11 named]# cat /etc/resolv.conf	# vi
# Generated by NetworkManager
search host.com
nameserver 192.168.0.11
	
[root@hdss7-11 named]# ping hdss7-21.host.com	
ping www.baidu.com
ping hdss7-21.host.com
ping hdss7-200

# 其他机器也都改成，然后互相ping域名，如ping hdss7-21.host.com  ping www.baidu.com
vi /etc/sysconfig/network-scripts/ifcfg-enp0s3
DNS1=192.168.0.11
systemctl restart network

# mac/windows上修改DNS，改为192.168.0.11，否则mac上访问不了（ping hdss7-21.host.com 失败）
```

## 签发证书

* 运维主机 HDSS7-200.host.com上：

```shell
# 安装CFSSL
[root@hdss7-200 ~]# wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/bin/cfssl
[root@hdss7-200 ~]# wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/bin/cfssl-json
[root@hdss7-200 ~]# wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O /usr/bin/cfssl-certinfo
chmod +x /usr/bin/cfssl*
root@hdss7-200 ~]# which cfssl-certinfo

# 签发证书
[root@worker4 bin]# cd /opt/
[root@worker4 opt]# mkdir certs
[root@worker4 opt]# cd certs/
[root@worker4 certs]# pwd
/opt/certs

# 签发根证书 -- 创建生成CA证书签名请求（csr）的JSON配置文件
[root@hdss7-200 ~]# vi /opt/certs/ca-csr.json
{
    "CN": "OldboyEdu",		# 机构名称，浏览器使用该字段验证网站是否合法，一般写的是域名，非常重要，浏览器使用该字段验证网站是否合法
    "hosts": [	
    ],
    "key": {			
        "algo": "rsa",		# 算法
        "size": 2048		# 长度
    },
    "names": [
        {
            "C": "CN",		# C，国家
            "ST": "beijing",	# ST 州，省
            "L": "beijing",	# L 地区 城市
            "O": "od",		# O 组织名称，公司名称
            "OU": "ops"		# OU 组织单位名称，公司部门
        }
    ],
    "ca": {
        "expiry": "175200h"	# expiry 过期时间，任何证书都有过期时间.20年
    }
}

#签发承载式证书
[root@hdss7-200 certs]# cfssl gencert -initca ca-csr.json | cfssl-json -bare ca
[root@hdss7-200 certs]# ll
总用量 16
-rw-r--r-- 1 root root  993 12月 10 11:54 ca.csr
-rw-r--r-- 1 root root  328 12月 10 11:53 ca-csr.json
-rw------- 1 root root 1679 12月 10 11:54 ca-key.pem	# 根证书的私钥
-rw-r--r-- 1 root root 1346 12月 10 11:54 ca.pem		# 根证书
```

## 部署docker环境

* 在node主机与运维主机上：21、22、200

```shell
[root@hdss7-200 ]# curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
[root@hdss7-200 ]# mkdir -p /etc/docker /data/docker
[root@hdss7-200 ]# vi /etc/docker/daemon.json
{
  "graph": "/data/docker",
  "storage-driver": "overlay2",
  "insecure-registries": ["registry.access.redhat.com","quay.io","harbor.od.com"],
  "registry-mirrors": ["https://q2gr04ke.mirror.aliyuncs.com"],
  "bip": "172.7.200.1/24",			# 定义k8s主机上k8s pod的ip地址网段
  "exec-opts": ["native.cgroupdriver=systemd"],
  "live-restore": true
}

# 机器内容器IP设置
## 各机器的bip不同，分别对应
# 如 192.168.0.21  为 172.7.11.1/24
# 如 192.168.0.22  为 172.7.22.1/24
# 如 192.168.0.200 为 172.7.200.1/24
# 注意insecure-registries中添加  harbor.od.com ，否则后面部署的harbor访问不了

[root@hdss7-200 ~]# systemctl start docker
[root@hdss7-200 ~]# systemctl enable docker
[root@hdss7-200 ~]# docker info
[root@hdss7-200 ~]# docker ps
```

## 部署docker镜像私有仓库Harbor

* hdss7-200上

```shell
[root@hdss7-200 ~]# tar -zxvf /data/harbor-offline-installer-v2.0.2.tgz -C /opt/
[root@hdss7-200 ~]# cd /opt
# 把软件包做版本标识，做一个软链接，便于以后升级
[root@hdss7-200 opt]# mv harbor/ harbor-v2.0.2
[root@hdss7-200 opt]# ln -s /opt/harbor-v2.0.2/ /opt/harbor

cd harbor
vi harbor.yml
# 修改点  注释掉https相关内容
	hostname: harbor.od.com
	http:
		port: 180
	log:
		location: /data/harbor/logs
	data_volume: /data/harbor		

[root@hdss7-200 harbor]# mkdir -p /data/harbor/logs /data/harbor

# 安装单机编排工具 docker-compose
[root@hdss7-200 harbor]# yum install docker-compose -y
# 验证
[root@hdss7-200 harbor]# rpm -qa docker-compose

# 安装harbor
[root@hdss7-200 harbor]# ./install.sh
[root@hdss7-200 harbor]# docker-compose ps

# 每次重启docker需要执行
[root@hdss7-200 harbor]# docker-compose up -d

# 安装nginx做反向代理
[root@hdss7-200 harbor]# yum install -y nginx
[root@hdss7-200 harbor]# vi /etc/nginx/conf.d/harbor.od.com.conf
server {
	listen			80;
	server_name	harbor.od.com;                
	client_max_body_size 1000m;
	location / {
		proxy_pass http://127.0.0.1:180;
	}
}
# 检查nginx配置文件
[root@hdss7-200 harbor]# nginx -t
# 启动nginx
[root@hdss7-200 harbor]# systemctl start nginx
[root@hdss7-200 harbor]# systemctl enable nginx

# hdss7-11 (master)上
[root@hdss7-11 named]# vi /var/named/od.com.zone 
$ORIGIN od.com.
$TTL 600        ; 10 minutes
@               IN SOA  dns.od.com. dnsadmin.od.com. (
                                2019120902 ; serial		# 往后滚动一个记录编号02，每次更改配置，必须滚动一个序号
                                10800      ; refresh (3 hours)
                                900        ; retry (15 minutes)
                                604800     ; expire (1 week)
                                86400      ; minimum (1 day)
                                )
                                NS   dns.od.com.
$TTL 60 ; 1 minute
dns                A    192.168.0.11
harbor             A    192.168.0.200
	
[root@hdss7-11 named]# systemctl restart named 
# 验证
[root@hdss7-11 named]# dig -t A harbor.od.com +short
192.168.0.200

# 200上
[root@hdss7-200 harbor]# curl harbor.od.com

# 浏览器上访问
http://harbor.od.com/
# 新建一个public项目，公开

# 200(worker4上)
[root@hdss7-200 harbor]# docker pull nginx:1.7.9
[root@hdss7-200 harbor]# docker tag nginx:1.7.9 harbor.od.com/public/nginx:v1.7.9 
[root@hdss7-200 harbor]# docker login harbor.od.com
[root@hdss7-200 harbor]# docker push harbor.od.com/public/nginx:v1.7.9

# 注意 vim /etc/docker/daemon.json中配置 insecure-registries中添加 "harbor.od.com"
# 否则无法访问harbor.od.com
"insecure-registries":["registry.access.redhat.com","quay.io", "harbor.od.com"],

# 重新启动harbor
cd harbor
docker-compose up -d
# 验证是否启动成功
curl harbor.od.com
```

# 部署主控节点服务

## 部署etcd集群

| 主机名            | 角色        | ip             |
| ----------------- | ----------- | -------------- |
| HDSS7-12.host.com | etcd lead   | 192.168.0.12   |
| HDSS7-21.host.com | etcd follow | 192.168.154.21 |
| HDSS7-22.host.com | etcd follow | 192.168.154.22 |

* HDss7-200

```shell
# 在HDss7-200上创建基于根证书的config配置文件 此文件夹内有，直接上传，不要粘贴复制
cd /opt/certs
vi ca-config.json

{
    "signing": {
        "default": {
            "expiry": "175200h"
        },
        "profiles": {
            "server": {
                "expiry": "175200h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth"
                ]
            },
            "client": {
                "expiry": "175200h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "client auth"
                ]
            },
            "peer": {				
                "expiry": "175200h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            }
        }
    }
}
```

```shell
# 此文档IP地址必须在文档内更改好再粘贴复制进去，IP地址为有可能装ETCD的主机，多一个IP为预备，-- 此文件夹内有，直接上传，不要粘贴复制
[root@hdss7-200 ~]# vi /opt/certs/etcd-peer-csr.json
{
    "CN": "k8s-etcd",
    "hosts": [
        "192.168.0.11",
        "192.168.0.12",
        "192.168.0.21",
        "192.168.0.22"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "beijing",
            "L": "beijing",
            "O": "od",
            "OU": "ops"
        }
    ]
}

# 生成etcd证书和私钥
[root@hdss7-200 certs]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=peer etcd-peer-csr.json |cfssl-json -bare etcd-peer
[root@hdss7-200 certs]# ll
总用量 36
-rw-r--r-- 1 root root  836 12月 10 16:29 ca-config.json
-rw-r--r-- 1 root root  993 12月 10 11:54 ca.csr
-rw-r--r-- 1 root root  328 12月 10 11:53 ca-csr.json
-rw------- 1 root root 1679 12月 10 11:54 ca-key.pem
-rw-r--r-- 1 root root 1346 12月 10 11:54 ca.pem
-rw-r--r-- 1 root root 1062 12月 10 16:31 etcd-peer.csr
-rw-r--r-- 1 root root  383 12月 10 16:31 etcd-peer-csr.json
-rw------- 1 root root 1679 12月 10 16:31 etcd-peer-key.pem
-rw-r--r-- 1 root root 1428 12月 10 16:31 etcd-peer.pem
```

* 192.168.0.12、192.168.0.21、192.168.0.22

```shell
# 在etcd主机上创建etcd用户
useradd -s /sbin/nologin -M etcd
id etcd

# 安装etcd
[root@hdss7-12 data]# tar -zxvf /data/etcd-v3.1.20-linux-amd64.tar.gz -C /opt/
[root@hdss7-12 data]# cd /opt/
[root@hdss7-12 opt]# mv etcd-v3.1.20-linux-amd64/ etcd-v3.1.20
# 创建软链接方便以后更新版本
[root@hdss7-12 opt]# ln -s /opt/etcd-v3.1.20/ /opt/etcd
[root@hdss7-12 opt]# cd etcd
# 创建目录，拷贝证书、私钥
[root@hdss7-12 etcd]# mkdir -p /opt/etcd/certs /data/etcd /data/logs/etcd-server
[root@hdss7-12 etcd]# cd certs/
# 将运维主机上生成的ca.pem  etc-peer-key.pem etc-peer.pem 拷贝到/opt/etcd/certs目录中，私钥文件权限为600
[root@hdss7-12 certs]# scp root@192.168.0.200:/opt/certs/ca.pem . 
[root@hdss7-12 certs]# scp root@192.168.0.200:/opt/certs/etcd-peer-key.pem .
[root@hdss7-12 certs]# scp root@192.168.0.200:/opt/certs/etcd-peer.pem .

# 更改属主属组
# cd /opt/etcd/certs
# chown -R etcd.etcd /opt/etcd/certs /data/etcd /data/logs/etcd-server
# ll
-rw-r--r-- 1 etcd etcd 1346 12月 10 16:52 ca.pem
-rw------- 1 etcd etcd 1679 12月 10 16:53 etcd-peer-key.pem
-rw-r--r-- 1 etcd etcd 1428 12月 10 16:53 etcd-peer.pem

# 创建etcd服务启动脚本IP地址改成本机IP -- 此文件本目录中有，上传修改即可，不要粘贴复制,格式容易出错
# 创建etcd服务启动脚本   # 不同：--name etcd-server-7-12、--name etcd-server-7-21、--name etcd-server-7-22
# scp root@192.168.0.12:/opt/etcd/etcd-server-startup.sh /opt/etcd/
[root@hdss7-12 certs]# vi /opt/etcd/etcd-server-startup.sh
#!/bin/sh
./etcd --name etcd-server-7-12 \
       --data-dir /data/etcd/etcd-server \
       --listen-peer-urls https://192.168.0.12:2380 \
       --listen-client-urls https://192.168.0.12:2379,http://127.0.0.1:2379 \
       --quota-backend-bytes 8000000000 \
       --initial-advertise-peer-urls https://192.168.0.12:2380 \
       --advertise-client-urls https://192.168.0.12:2379,http://127.0.0.1:2379 \
       --initial-cluster  etcd-server-7-12=https://192.168.0.12:2380,etcd-server-7-21=https://192.168.0.21:2380,etcd-server-7-22=https://192.168.0.22:2380 \
       --ca-file ./certs/ca.pem \
       --cert-file ./certs/etcd-peer.pem \
       --key-file ./certs/etcd-peer-key.pem \
       --client-cert-auth  \
       --trusted-ca-file ./certs/ca.pem \
       --peer-ca-file ./certs/ca.pem \
       --peer-cert-file ./certs/etcd-peer.pem \
       --peer-key-file ./certs/etcd-peer-key.pem \
       --peer-client-cert-auth \
       --peer-trusted-ca-file ./certs/ca.pem \
       --log-output stdout

# 赋予执行权限
[root@hdss7-12 certs]# chmod +x /opt/etcd/etcd-server-startup.sh

# 更改属主属组
cd /opt/etcd
[root@hdss7-12  certs]# chown -R etcd.etcd /opt/etcd-v3.1.20/
[root@hdss7-12  certs]# chown -R etcd.etcd /data/etcd/
[root@hdss7-12  certs]# chown -R etcd.etcd /data/logs/etcd-server/


# 使etcd后端运行
[root@hdss7-12 certs]# yum install supervisor -y
[root@hdss7-12 certs]# systemctl start supervisord
[root@hdss7-12 certs]# systemctl enable supervisord

# 更改supervisord的配置文件：[program:etcd-server-7-12]名字需要根据实际更改
# scp root@192.168.0.12:/etc/supervisord.d/etcd-server.ini /etc/supervisord.d/
[root@hdss7-12 logs]# vi /etc/supervisord.d/etcd-server.ini
[program:etcd-server-7-12]
command=sh /opt/etcd/etcd-server-startup.sh                        ; the program (relative uses PATH, can take args)	
numprocs=1                                                      ; number of processes copies to start (def 1)
directory=/opt/etcd                                             ; directory to cwd to before exec (def no cwd)
autostart=true                                                  ; start at supervisord start (default: true)
autorestart=true                                                ; retstart at unexpected quit (default: true)
startsecs=30                                                    ; number of secs prog must stay running (def. 1)
startretries=3                                                  ; max # of serial start failures (default 3)
exitcodes=0,2                                                   ; 'expected' exit codes for process (default 0,2)
stopsignal=QUIT                                                 ; signal used to kill process (default TERM)
stopwaitsecs=10                                                 ; max num secs to wait b4 SIGKILL (default 10)
user=etcd                                                       ; setuid to this UNIX account to run the program
redirect_stderr=true                                            ; redirect proc stderr to stdout (default false)
stdout_logfile=/data/logs/etcd-server/etcd.stdout.log           ; stdout log path, NONE for none; default AUTO
stdout_logfile_maxbytes=64MB                                    ; max # logfile bytes b4 rotation (default 50MB)
stdout_logfile_backups=4                                        ; # of stdout logfile backups (default 10)
stdout_capture_maxbytes=1MB                                     ; number of bytes in 'capturemode' (default 0)
stdout_events_enabled=false                                     ; emit events on stdout writes (default false)

# 创建后端启动etcd
[root@hdss7-12 logs]# supervisorctl update
etcd-server-7-12: added process group
[root@hdss7-12 logs]# supervisorctl status
etcd-server-7-12                 STARTING 
[root@hdss7-12 logs]# netstat -luntp|grep etcd
tcp        0      0 192.168.0.12:2379     0.0.0.0:*               LISTEN      19395/./etcd        
tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      19395/./etcd        
tcp        0      0 192.168.0.12:2380     0.0.0.0:*               LISTEN      19395/./etcd  

# 查看日志
[root@worker1 etcd]# tail -fn 200 /data/logs/etcd-server/etcd.stdout.log

# 任意节点检测etcd集群健康状态
[root@worker2 etcd]# ./etcdctl cluster-health
[root@worker2 etcd]# ./etcdctl member list
```

## 部署kube-apiserver

* 集群规划

```shell
HDSS7-21.host.com	kube-apiserver		192.168.0.21
HDSS7-22.host.com	kube-apiserver		192.168.0.22
HDSS7-11.host.com	4层负载均衡		192.168.0.11
HDSS7-12.host.com	4层负载均衡		192.168.0.12
# 注意：这里192.168.0.11和192.168.0.12使用nginx做4层负载均衡器，用keepalive跑一个vip：192.168.0.10，代理两个kube-apiserver，实现高可用
```

* 运维主机HDSS-200.host.com上
  * 签发apiserver-client证书：apiserver与etc通信用的证书。apiserver是客户端，etcd是服务端

```shell
# 创建生成证书签名请求（csr）的JSON配置文件	-- 此目录下有，直接上传修改，不要粘贴复制
[root@hdss7-200 ~]# vi /opt/certs/client-csr.json
{
    "CN": "k8s-node",
    "hosts": [
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "beijing",
            "L": "beijing",
            "O": "od",
            "OU": "ops"
        }
    ]
}

[root@hdss7-200 ~]# cd /opt/certs/
[root@hdss7-200 certs]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client client-csr.json |cfssl-json -bare client

# 创建签名请求（csr）的JSON配置文件，apiserver，server端证书 -- 直接上传
[root@hdss7-200 certs]# vi apiserver-csr.json
{
    "CN": "k8s-apiserver",
    "hosts": [
        "127.0.0.1",
        "10.254.0.1",
        "kubernetes.default",
        "kubernetes.default.svc",
        "kubernetes.default.svc.cluster",
        "kubernetes.default.svc.cluster.local",
        "192.168.0.10",
        "192.168.0.21",
        "192.168.0.22",
        "192.168.0.23"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "beijing",
            "L": "beijing",
            "O": "od",
            "OU": "ops"
        }
    ]
}

[root@hdss7-200 certs]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server apiserver-csr.json | cfssl-json -bare apiserver

[root@hdss7-200 certs]# ll
总用量 80
total 24
-rw------- 1 root root 1679 Nov 10 17:42 apiserver-key.pem
-rw-r--r-- 1 root root 1598 Nov 10 17:42 apiserver.pem
-rw------- 1 root root 1679 Nov 10 17:41 ca-key.pem
-rw-r--r-- 1 root root 1346 Nov 10 17:41 ca.pem
-rw------- 1 root root 1675 Nov 10 17:41 client-key.pem
-rw-r--r-- 1 root root 1363 Nov 10 17:41 client.pem
```

* 以HDSS7-21.host.com主机为例，另外一台运算节点HDSS7-22.host.com部署方法类似

```shell
scp /Users/dingyuanjie/work/tmp_k8s/soft/kubernetes-server-linux-amd64-v1.15.2.tar.gz root@192.168.0.21:/data/
# 安装
[root@hdss7-21 data]# tar -zxvf /data/kubernetes-server-linux-amd64-v1.15.2.tar.gz -C /opt/
[root@hdss7-21 data]# cd /opt/
[root@hdss7-21 opt]# mv kubernetes/ kubernetes-v1.15.2
# 做软连接，方便以后更新
[root@hdss7-21 opt]# ln -s /opt/kubernetes-v1.15.2/ /opt/kubernetes
[root@hdss7-21 opt]# ll
总用量 0
drwx--x--x 4 root root  28 12月 10 14:28 containerd
lrwxrwxrwx 1 root root  17 12月 10 16:45 etcd -> /opt/etcd-v3.1.20
drwxr-xr-x 4 etcd etcd 166 12月 10 17:43 etcd-v3.1.20
lrwxrwxrwx 1 root root  24 12月 10 18:33 kubernetes -> /opt/kubernetes-v1.15.2/
drwxr-xr-x 4 root root  79 8月   5 18:01 kubernetes-v1.15.2
drwxr-xr-x 2 root root  97 12月 10 18:29 src
[root@hdss7-21 opt]# cd kubernetes
# 删除源码包
[root@hdss7-21 kubernetes]# rm -rf kubernetes-src.tar.gz
[root@hdss7-21 kubernetes]# cd server/bin
# 删除没用的文件docker镜像等
[root@hdss7-21 bin]# rm -rf *_tag *.tar
# 剩余一些可执行文件
[root@hdss7-21 bin]# ll
总用量 884636
-rwxr-xr-x 1 root root  43534816 8月   5 18:01 apiextensions-apiserver
-rwxr-xr-x 1 root root 100548640 8月   5 18:01 cloud-controller-manager
-rwxr-xr-x 1 root root 200648416 8月   5 18:01 hyperkube
-rwxr-xr-x 1 root root  40182208 8月   5 18:01 kubeadm
-rwxr-xr-x 1 root root 164501920 8月   5 18:01 kube-apiserver
-rwxr-xr-x 1 root root 116397088 8月   5 18:01 kube-controller-manager
-rwxr-xr-x 1 root root  42985504 8月   5 18:01 kubectl
-rwxr-xr-x 1 root root 119616640 8月   5 18:01 kubelet
-rwxr-xr-x 1 root root  36987488 8月   5 18:01 kube-proxy
-rwxr-xr-x 1 root root  38786144 8月   5 18:01 kube-scheduler
-rwxr-xr-x 1 root root   1648224 8月   5 18:01 mounter

# 拷贝证书
[root@hdss7-21 bin]# mkdir cert
[root@hdss7-21 bin]# cd cert/
# 最后有个点，表示拷贝到当前目录
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/ca.pem . 
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/ca-key.pem .
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/client.pem .
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/client-key.pem .
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/apiserver.pem .
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/apiserver-key.pem .

[root@hdss7-21 cert]# cd ..
[root@hdss7-21 bin]# mkdir conf
[root@hdss7-21 bin]# cd conf/
# [root@hdss7-22 conf]# scp root@192.168.0.21:/opt/kubernetes/server/bin/conf/audit.yaml /opt/kubernetes/server/bin/conf/
[root@hdss7-21 conf]# vi audit.yaml
apiVersion: audit.k8s.io/v1beta1 # This is required.
kind: Policy
# Don't generate audit events for all requests in RequestReceived stage.
omitStages:
  - "RequestReceived"
rules:
  # Log pod changes at RequestResponse level
  - level: RequestResponse
    resources:
    - group: ""
      # Resource "pods" doesn't match requests to any subresource of pods,
      # which is consistent with the RBAC policy.
      resources: ["pods"]
  # Log "pods/log", "pods/status" at Metadata level
  - level: Metadata
    resources:
    - group: ""
      resources: ["pods/log", "pods/status"]

  # Don't log requests to a configmap called "controller-leader"
  - level: None
    resources:
    - group: ""
      resources: ["configmaps"]
      resourceNames: ["controller-leader"]

  # Don't log watch requests by the "system:kube-proxy" on endpoints or services
  - level: None
    users: ["system:kube-proxy"]
    verbs: ["watch"]
    resources:
    - group: "" # core API group
      resources: ["endpoints", "services"]

  # Don't log authenticated requests to certain non-resource URL paths.
  - level: None
    userGroups: ["system:authenticated"]
    nonResourceURLs:
    - "/api*" # Wildcard matching.
    - "/version"

  # Log the request body of configmap changes in kube-system.
  - level: Request
    resources:
    - group: "" # core API group
      resources: ["configmaps"]
    # This rule only applies to resources in the "kube-system" namespace.
    # The empty string "" can be used to select non-namespaced resources.
    namespaces: ["kube-system"]

  # Log configmap and secret changes in all other namespaces at the Metadata level.
  - level: Metadata
    resources:
    - group: "" # core API group
      resources: ["secrets", "configmaps"]

  # Log all other resources in core and extensions at the Request level.
  - level: Request
    resources:
    - group: "" # core API group
    - group: "extensions" # Version of group should NOT be included.

  # A catch-all rule to log all other requests at the Metadata level.
  - level: Metadata
    # Long-running requests like watches that fall under this rule will not
    # generate an audit event in RequestReceived.
    omitStages:
      - "RequestReceived"

# 编写启动脚本	-- 直接上传
# [root@hdss7-22 conf]# scp root@192.168.0.21:/opt/kubernetes/server/bin/kube-apiserver.sh /opt/kubernetes/server/bin/
[root@hdss7-21 conf]# vi /opt/kubernetes/server/bin/kube-apiserver.sh
#!/bin/bash
./kube-apiserver \
  --apiserver-count 2 \			# apiserver的数量
  --audit-log-path /data/logs/kubernetes/kube-apiserver/audit-log \
  --audit-policy-file ./conf/audit.yaml \
  --authorization-mode RBAC \
  --client-ca-file ./cert/ca.pem \
  --requestheader-client-ca-file ./cert/ca.pem \
  --enable-admission-plugins
NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota \
  --etcd-cafile ./cert/ca.pem \
  --etcd-certfile ./cert/client.pem \
  --etcd-keyfile ./cert/client-key.pem \
  --etcd-servers https://192.168.0.12:2379,https://192.168.0.21:2379,https://192.168.0.22:2379 \
  --service-account-key-file ./cert/ca-key.pem \
  --service-cluster-ip-range 10.254.0.0/16 \
  --service-node-port-range 3000-29999 \
  --target-ram-mb=1024 \
  --kubelet-client-certificate ./cert/client.pem \
  --kubelet-client-key ./cert/client-key.pem \
  --log-dir  /data/logs/kubernetes/kube-apiserver \
  --tls-cert-file ./cert/apiserver.pem \
  --tls-private-key-file ./cert/apiserver-key.pem \
  
# 查看帮助命令，查看每行的意思
[root@hdss7-21 bin]# ./kube-apiserver --help|grep -A 5 target-ram-mb 

chmod +x /opt/kubernetes/server/bin/kube-apiserver.sh

# 创建后台启动
[root@hdss7-21 bin]# vi /etc/supervisord.d/kube-apiserver.ini
[program:kube-apiserver-7-21]					# 21根据实际IP地址更改
command=sh /opt/kubernetes/server/bin/kube-apiserver.sh            ; the program (relative uses PATH, can take args)
numprocs=1                                                      ; number of processes copies to start (def 1)
directory=/opt/kubernetes/server/bin                            ; directory to cwd to before exec (def no cwd)
autostart=true                                                  ; start at supervisord start (default: true)
autorestart=true                                                ; retstart at unexpected quit (default: true)
startsecs=30                                                    ; number of secs prog must stay running (def. 1)
startretries=3                                                  ; max # of serial start failures (default 3)
exitcodes=0,2                                                   ; 'expected' exit codes for process (default 0,2)
stopsignal=QUIT                                                 ; signal used to kill process (default TERM)
stopwaitsecs=10                                                 ; max num secs to wait b4 SIGKILL (default 10)
user=root                                                       ; setuid to this UNIX account to run the program
redirect_stderr=true                                            ; redirect proc stderr to stdout (default false)
stdout_logfile=/data/logs/kubernetes/kube-apiserver/apiserver.stdout.log        ; stderr log path, NONE for none; default AUTO
stdout_logfile_maxbytes=64MB                                    ; max # logfile bytes b4 rotation (default 50MB)
stdout_logfile_backups=4                                        ; # of stdout logfile backups (default 10)
stdout_capture_maxbytes=1MB                                     ; number of bytes in 'capturemode' (default 0)
stdout_events_enabled=false                                     ; emit events on stdout writes (default false)

[root@hdss7-21 bin]# mkdir -p /data/logs/kubernetes/kube-apiserver
[root@hdss7-21 bin]# supervisorctl update
[root@worker2 bin]# supervisorctl status
etcd-server-7-21                 RUNNING   pid 2723, uptime 2:04:39
kube-apiserver-7-21              RUNNING   pid 2945, uptime 0:03:14
[root@hdss7-21 bin]# netstat -luntp | grep kube-api
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      27303/./kube-apiser 
tcp6       0      0 :::6443                 :::*                    LISTEN      27303/./kube-apiser 
```

![image-20200810073250993](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200810073250993.png)

## 配置L4反向代理

* 部署在hdss7-11 hdss7-12机器上，用VIP 192.168.0.10的7443端口，反代hdss7-21、hdss7-22的apiserver6443端口
* HDSS7-11和HDSS7-12上同时操作

```shell
# nginx配置
[root@hdss7-11 ~]# yum install -y nginx	

# scp root@192.168.0.11:/etc/nginx/nginx.conf /etc/nginx/
[root@hdss7-11 ~]# vi /etc/nginx/nginx.conf		-- 直接上传
# 放在最后
stream {
    upstream kube-apiserver {
        server 192.168.0.21:6443     max_fails=3 fail_timeout=30s;
        server 192.168.0.22:6443     max_fails=3 fail_timeout=30s;
    }
    server {
        listen 7443;
        proxy_connect_timeout 2s;
        proxy_timeout 900s;
        proxy_pass kube-apiserver;
    }
}

# 检查配置文件
[root@hdss7-11 ~]# nginx -t
[root@hdss7-11 ~]# systemctl start nginx
[root@hdss7-11 ~]# systemctl enable nginx

# keepalived安装配置
[root@hdss7-11 ~]# yum install keepalived -y

# 编写监听脚本	-- 直接上传
# scp root@192.168.0.11:/etc/keepalived/check_port.sh /etc/keepalived/
[root@hdss7-11 ~]# vi /etc/keepalived/check_port.sh	
#!/bin/bash
#keepalived 监控端口脚本
#使用方法：
#在keepalived的配置文件中
#vrrp_script check_port {#创建一个vrrp_script脚本,检查配置
#    script "/etc/keepalived/check_port.sh 6379" #配置监听的端口
#    interval 2 #检查脚本的频率,单位（秒）
#}
CHK_PORT=$1
if [ -n "$CHK_PORT" ];then
        PORT_PROCESS=`ss -lnt|grep $CHK_PORT|wc -l`
        if [ $PORT_PROCESS -eq 0 ];then
                echo "Port $CHK_PORT Is Not Used,End."
                exit 1
        fi
else
        echo "Check Port Cant Be Empty!"
fi

[root@hdss7-11 ~]# # chmod +x /etc/keepalived/check_port.sh

# 配置keepalived	-- 删除原文件，直接上传修改
# keepalived 主:
[root@hdss7-11 ~]# vi /etc/keepalived/keepalived.conf 
! Configuration File for keepalived

global_defs {
   router_id 192.168.0.11

}

vrrp_script chk_nginx {
    script "/etc/keepalived/check_port.sh 7443"
    interval 2
    weight -20
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0	# 根据实际网卡更改  ip add 查看本机实际的值 ，例如 enp0s3
    virtual_router_id 251
    priority 100
    advert_int 1
    mcast_src_ip 192.168.0.11
    nopreempt

    authentication {
        auth_type PASS
        auth_pass 11111111
    }
    track_script {
         chk_nginx
    }
    virtual_ipaddress {
        192.168.0.10
    }
}

# keepalived从:    -- 直接上传
[root@hdss7-12 ~]# vi /etc/keepalived/keepalived.conf 
! Configuration File for keepalived
global_defs {
        router_id 192.168.0.12
				script_user root
        enable_script_security 
}
vrrp_script chk_nginx {
        script "/etc/keepalived/check_port.sh 7443"
        interval 2
        weight -20
}
vrrp_instance VI_1 {
        state BACKUP
        interface eth0		# 根据实际网卡更改 ip add 查看本机实际的值 ，例如 enp0s3
        virtual_router_id 251
        mcast_src_ip 192.168.0.12
        priority 90
        advert_int 1
        authentication {
                auth_type PASS
                auth_pass 11111111
        }
        track_script {
                chk_nginx
        }
        virtual_ipaddress {
                192.168.0.10
        }
}

[root@hdss7-11 keepalived]# ss -lnt|grep 7443|wc -l         
1
[root@hdss7-11 ~]# systemctl start keepalived
[root@hdss7-11 ~]# systemctl enable keepalived

[root@hdss7-11 ~]# netstat -luntp|grep 7443
tcp        0      0 0.0.0.0:7443            0.0.0.0:*               LISTEN      1811/nginx: master

[root@hdss7-11 ~]# ss -lnt|grep 7443|wc -l
1

# 查看日志
[root@hdss7-11 ~]# tail -fn 200 /var/log/messages

# 如果vip出现变动，主keepalived恢复后，一定要确认主keepalived端口起来，服务搞好，重启keepalived，是vip变回主keepalived
[root@hdss7-11 ~]# netstat -luntp | grep 7443
tcp        0      0 0.0.0.0:7443            0.0.0.0:*               LISTEN      22071/nginx: master 

# 只主node上有虚拟ip即可
[root@hdss7-11 ~]# ip add
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:8d:59:b4 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.11/24 brd 192.168.0.255 scope global noprefixroute enp0s3
       valid_lft forever preferred_lft forever
		# 虚拟IP       
    inet 192.168.0.10/32 scope global enp0s3
       valid_lft forever preferred_lft forever
    inet6 fe80::1a98:a51e:b495:beb9/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:65:c7:17:7f brd ff:ff:ff:ff:ff:ff
    inet 172.7.11.1/24 brd 172.7.11.255 scope global docker0
       valid_lft forever preferred_lft forever
```

![image-20200810194224472](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200810194224472.png)

## 部署controller-manager

![image-20200809144459056](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200809144459056.png)

* 集群规划

  ```shell
  HDS7-21.host.com		controller-manager		192.168.153.21
  HDS7-22.host.com		controller-manager		192.168.153.22
  ```

* 以HDS7-21.host.com主机为例，另外一台运算节点HDS7-22.host.com安装部署方法类似

  ```shell
  # 创建启动脚本：	-- 直接上传
  # HDS7-21.host.com上
  [root@hdss7-21 ~]# vi /opt/kubernetes/server/bin/kube-controller-manager.sh
  #!/bin/sh
  ./kube-controller-manager \
    --cluster-cidr 172.7.0.0/16 \
    --leader-elect true \
    --log-dir /data/logs/kubernetes/kube-controller-manager \
    --master http://127.0.0.1:8080 \
    --service-account-private-key-file ./cert/ca-key.pem \
    --service-cluster-ip-range 10.254.0.0/16 \
    --root-ca-file ./cert/ca.pem \
    --v 2
    
  [root@hdss7-21 ~]# mkdir -p /data/logs/kubernetes/kube-controller-manager
  [root@hdss7-21 ~]# chmod +x /opt/kubernetes/server/bin/kube-controller-manager.sh
  
  # 创建supervisor配置
  [root@hdss7-21 ~]# vi /etc/supervisord.d/kube-conntroller-manager.ini
  [program:kube-controller-manager-7-21]
  command=sh /opt/kubernetes/server/bin/kube-controller-manager.sh                     ; the program (relative uses PATH, can take args)
  numprocs=1                                                                        ; number of processes copies to start (def 1)
  directory=/opt/kubernetes/server/bin                                              ; directory to cwd to before exec (def no cwd)
  autostart=true                                                                    ; start at supervisord start (default: true)
  autorestart=true                                                                  ; retstart at unexpected quit (default: true)
  startsecs=30                                                                      ; number of secs prog must stay running (def. 1)
  startretries=3                                                                    ; max # of serial start failures (default 3)
  exitcodes=0,2                                                                     ; 'expected' exit codes for process (default 0,2)
  stopsignal=QUIT                                                                   ; signal used to kill process (default TERM)
  stopwaitsecs=10                                                                   ; max num secs to wait b4 SIGKILL (default 10)
  user=root                                                                         ; setuid to this UNIX account to run the program
  redirect_stderr=true                                                              ; redirect proc stderr to stdout (default false)
  stdout_logfile=/data/logs/kubernetes/kube-controller-manager/controller.stdout.log  ; stderr log path, NONE for none; default AUTO
  stdout_logfile_maxbytes=64MB                                                      ; max # logfile bytes b4 rotation (default 50MB)
  stdout_logfile_backups=4                                                          ; # of stdout logfile backups (default 10)
  stdout_capture_maxbytes=1MB                                                       ; number of bytes in 'capturemode' (default 0)
  stdout_events_enabled=false                                                       ; emit events on stdout writes (default false)
  
  # 启动服务并检测
  [root@worker2 ~]# supervisorctl update
  kube-controller-manager-7-21: added process group
  [root@worker2 ~]# supervisorctl status
  etcd-server-7-21                 RUNNING   pid 1052, uptime 12:14:54
  kube-apiserver-7-21              RUNNING   pid 1053, uptime 12:14:54
  kube-controller-manager-7-21     RUNNING   pid 2907, uptime 0:00:39
  ```

## 部署kube-scheduler

* 以HDS7-21.host.com主机为例，另外一台运算节点HDS7-22.host.com安装部署方法类似

  ```shell
  # 创建启动脚本
  vi /opt/kubernetes/server/bin/kube-scheduler.sh
  
  #!/bin/sh
  ./kube-scheduler \
    --leader-elect  \
    --log-dir /data/logs/kubernetes/kube-scheduler \
    --master http://127.0.0.1:8080 \
    --v 2
   
  [root@hdss7-22 bin]# chmod +x /opt/kubernetes/server/bin/kube-scheduler.sh
  
  # 创建supervisor配置 
  vi /etc/supervisord.d/kube-scheduler.ini
  
  [program:kube-scheduler-7-21]
  command=sh /opt/kubernetes/server/bin/kube-scheduler.sh                     ; the program (relative uses PATH, can take args)
  numprocs=1                                                               ; number of processes copies to start (def 1)
  directory=/opt/kubernetes/server/bin                                     ; directory to cwd to before exec (def no cwd)
  autostart=true                                                           ; start at supervisord start (default: true)
  autorestart=true                                                         ; retstart at unexpected quit (default: true)
  startsecs=30                                                             ; number of secs prog must stay running (def. 1)
  startretries=3                                                           ; max # of serial start failures (default 3)
  exitcodes=0,2                                                            ; 'expected' exit codes for process (default 0,2)
  stopsignal=QUIT                                                          ; signal used to kill process (default TERM)
  stopwaitsecs=10                                                          ; max num secs to wait b4 SIGKILL (default 10)
  user=root                                                                ; setuid to this UNIX account to run the program
  redirect_stderr=true                                                     ; redirect proc stderr to stdout (default false)
  stdout_logfile=/data/logs/kubernetes/kube-scheduler/scheduler.stdout.log ; stderr log path, NONE for none; default AUTO
  stdout_logfile_maxbytes=64MB                                             ; max # logfile bytes b4 rotation (default 50MB)
  stdout_logfile_backups=4                                                 ; # of stdout logfile backups (default 10)
  stdout_capture_maxbytes=1MB                                              ; number of bytes in 'capturemode' (default 0)
  stdout_events_enabled=false                                              ; emit events on stdout writes (default false)
  
  [root@hdss7-22 bin]# mkdir -p /data/logs/kubernetes/kube-scheduler
  
  # 启动服务并检测
  [root@hdss7-21 ~]# supervisorctl update
  kube-scheduler-7-21: added process group
  [root@hdss7-21 bin]# supervisorctl status
  etcd-server-7-21                 RUNNING   pid 27300, uptime 18:45:03
  kube-apiserver-7-21              RUNNING   pid 27301, uptime 18:45:03
  kube-controller-manager-7-21     RUNNING   pid 79809, uptime 1:24:14
  kube-scheduler-7-21              RUNNING   pid 81360, uptime 0:54:28
  
  # 检测集群状态
  ln -s /opt/kubernetes/server/bin/kubectl /usr/bin/kubectl
  [root@worker3 ~]# which kubectl
  /usr/bin/kubectl
  [root@hdss7-21 bin]# kubectl get cs
  NAME                 STATUS    MESSAGE              ERROR
  scheduler            Healthy   ok                   
  controller-manager   Healthy   ok                   
  etcd-2               Healthy   {"health": "true"}   
  etcd-0               Healthy   {"health": "true"}   
  etcd-1               Healthy   {"health": "true"}
  ```
  

# 部署运算节点服务

## kubelet

* 集群规划

  ```shell
  HDSS7-21.host.com			kubelet				192.168.0.21
  HDSS7-22.host.com			kubelet				192.168.0.22
  ```

* 以HDSS7-21.host.com主机为例，另外一台计算节点HDSS7-22.host.com安装部署方法类似

* 签发kubelet证书
  
  * 运维主机 HDSS7-200.host.com
  
    ```shell
    # 创建生成证书签名请求（csr）的JSON配置文件
    [root@hdss7-200 etc]# cd /opt/certs/
    [root@hdss7-200 certs]# vi kubelet-csr.json
    {
        "CN": "k8s-kubelet",
        "hosts": [
        "127.0.0.1",
        "192.168.0.10",
        "192.168.0.21",
        "192.168.0.22",
        "192.168.0.23",
        "192.168.0.24",
        "192.168.0.25",
        "192.168.0.26",
        "192.168.0.27",
        "192.168.0.28"
        ],
        "key": {
            "algo": "rsa",
            "size": 2048
        },
        "names": [
            {
                "C": "CN",
                "ST": "beijing",
                "L": "beijing",
                "O": "od",
                "OU": "ops"
            }
        ]
    }
    
    # 生成证书
    [root@hdss7-200 certs]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server kubelet-csr.json | cfssl-json -bare kubelet
    [root@hdss7-200 certs]# ll
    -rw-r--r-- 1 root root 1115 12月 11 16:16 kubelet.csr
    -rw-r--r-- 1 root root  498 12月 11 16:16 kubelet-csr.json
    -rw------- 1 root root 1679 12月 11 16:16 kubelet-key.pem
    -rw-r--r-- 1 root root 1468 12月 11 16:16 kubelet.pem
    ```
  
* hdss7-21、hdss7-22

```shell
# 拷贝证书、私钥，注意私钥文件属性600，拷贝至：/opt/kubernetes/server/bin/cert/
[root@hdss7-21 ~]# cd /opt/kubernetes/server/bin/cert/
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/kubelet.pem .
[root@hdss7-21 cert]# scp hdss7-200:/opt/certs/kubelet-key.pem .

# 分发证书   # 只做一次，最后生成的 kubelet.kubeconfig 拷贝至其他节点
[root@hdss7-21 cert]# cd /opt/kubernetes/server/bin/conf
# 创建配置
## set-cluster        # 虚拟IP  
[root@hdss7-21 conf]# kubectl config set-cluster myk8s \
    --certificate-authority=/opt/kubernetes/server/bin/cert/ca.pem \
    --embed-certs=true \
    --server=https://192.168.0.10:7443 \
    --kubeconfig=kubelet.kubeconfig

# Cluster "myk8s" set.

## set-credentials
[root@hdss7-21 conf]# kubectl config set-credentials k8s-node \
  --client-certificate=/opt/kubernetes/server/bin/cert/client.pem \
  --client-key=/opt/kubernetes/server/bin/cert/client-key.pem \
  --embed-certs=true \
  --kubeconfig=kubelet.kubeconfig 

# User "k8s-node" set.

## set-context
[root@hdss7-21 conf]# kubectl config set-context myk8s-context \
  --cluster=myk8s \
  --user=k8s-node \
  --kubeconfig=kubelet.kubeconfig

# Context "myk8s-context" created.

## use-context  
[root@hdss7-21 conf]# kubectl config use-context myk8s-context --kubeconfig=kubelet.kubeconfig
# Switched to context "myk8s-context".

# scp /opt/kubernetes/server/bin/conf/kubelet.kubeconfig root@192.168.0.22:/opt/kubernetes/server/bin/conf

# 授予权限，角色绑定	-- 只创建一次就好，存到etcd里,然后拷贝到各个node节点上
[root@hdss7-21 conf]# vi k8s-node.yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: k8s-node
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:node
subjects:
- apiGroup: rbac.authorization.k8s.io
	kind: User
	name: k8s-node

[root@hdss7-21 conf]# kubectl create -f k8s-node.yaml
clusterrolebinding.rbac.authorization.k8s.io/k8s-node created
[root@hdss7-21 conf]# kubectl get clusterrolebinding k8s-node
NAME       AGE
k8s-node   55s
[root@hdss7-21 conf]# kubectl get clusterrolebinding k8s-node -o yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding             # k8s一切皆资源
metadata:
  creationTimestamp: "2020-08-10T12:30:36Z"
  name: k8s-node
  resourceVersion: "12802"
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/k8s-node
  uid: 5db31f5f-106a-486d-97d2-6a5cd870cc5b
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:node
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: k8s-node        # k8s-node用户成为集群运算节点的权限
  
# 准备pause基础镜像	-- 边车模式
# 运维主机hdss7-200.host.com上：
[root@hdss7-200 ~]# docker pull kubernetes/pause
[root@hdss7-200 ~]# docker tag f9d5de079539 harbor.od.com/public/pause:latest
# # 提交至私有仓库（harbor）中
[root@hdss7-200 ~]# docker push harbor.od.com/public/pause:latest

# 都操作，不拷贝了
# hdss7-22上
# [root@hdss7-22 ~]# cd /opt/kubernetes/server/bin/conf
# [root@hdss7-22 conf]# scp root@192.168.0.21:/opt/kubernetes/server/bin/conf/kubelet.kubeconfig .
# [root@hdss7-22 ~]# scp hdss7-21:/opt/kubernetes/server/bin/conf/kubelet.kubeconfig .
```

```shell
# 192.168.0.21、192.168.0.22

# 创建kubelet启动脚本 # 更改主机名
[root@hdss7-21 conf]# vi /opt/kubernetes/server/bin/kubelet.sh
#!/bin/sh
./kubelet \
  --anonymous-auth=false \
  --cgroup-driver systemd \
  --cluster-dns 10.254.0.2 \
  --cluster-domain cluster.local \
  --runtime-cgroups=/systemd/system.slice \
  --kubelet-cgroups=/systemd/system.slice \
  --fail-swap-on="false" \
  --client-ca-file ./cert/ca.pem \
  --tls-cert-file ./cert/kubelet.pem \
  --tls-private-key-file ./cert/kubelet-key.pem \
  --hostname-override hdss7-21.host.com \
  --image-gc-high-threshold 20 \
  --image-gc-low-threshold 10 \
  --kubeconfig ./conf/kubelet.kubeconfig \
  --log-dir /data/logs/kubernetes/kube-kubelet \
  --pod-infra-container-image harbor.od.com/public/pause:latest \
  --root-dir /data/kubelet

[root@hdss7-21 conf]# mkdir -p /data/logs/kubernetes/kube-kubelet /data/kubelet
[root@hdss7-21 conf]# chmod +x /opt/kubernetes/server/bin/kubelet.sh

# 创建supervisor配置
[root@hdss7-21 conf]# vi /etc/supervisord.d/kube-kubelet.ini  
[program:kube-kubelet-7-21]		        # 根据实际情况修改     
command=sh /opt/kubernetes/server/bin/kubelet.sh     ; the program (relative uses PATH, can take args)
numprocs=1                                        ; number of processes copies to start (def 1)
directory=/opt/kubernetes/server/bin              ; directory to cwd to before exec (def no cwd)
autostart=true                                    ; start at supervisord start (default: true)
autorestart=true              		          ; retstart at unexpected quit (default: true)
startsecs=30                                      ; number of secs prog must stay running (def. 1)
startretries=3                                    ; max # of serial start failures (default 3)
exitcodes=0,2                                     ; 'expected' exit codes for process (default 0,2)
stopsignal=QUIT                                   ; signal used to kill process (default TERM)
stopwaitsecs=10                                   ; max num secs to wait b4 SIGKILL (default 10)
user=root                                         ; setuid to this UNIX account to run the program
redirect_stderr=true                              ; redirect proc stderr to stdout (default false)
stdout_logfile=/data/logs/kubernetes/kube-kubelet/kubelet.stdout.log   ; stderr log path, NONE for none; default AUTO
stdout_logfile_maxbytes=64MB                      ; max # logfile bytes b4 rotation (default 50MB)
stdout_logfile_backups=4                          ; # of stdout logfile backups (default 10)
stdout_capture_maxbytes=1MB                       ; number of bytes in 'capturemode' (default 0)
stdout_events_enabled=false                       ; emit events on stdout writes (default false)

[root@hdss7-21 conf]# supervisorctl update
kube-kubelet-7-21: added process group
# supervisorctl help
# supervisorctl reload
# supervisorctl restart kube-kubelet-7-21
[root@hdss7-21 bin]# supervisorctl status
etcd-server-7-21                 RUNNING   pid 6565, uptime 0:24:15
kube-apiserver-7-21              RUNNING   pid 6566, uptime 0:24:15
kube-controller-manager-7-21     RUNNING   pid 6551, uptime 0:24:15
kube-kubelet-7-21                RUNNING   pid 16663, uptime 0:01:14
kube-scheduler-7-21              RUNNING   pid 6552, uptime 0:24:15

# 正常情况
[root@hdss7-21 cert]# kubectl get nodes
NAME                STATUS   ROLES    AGE     VERSION
hdss7-21.host.com   Ready    <none>   15h     v1.15.2
hdss7-22.host.com   Ready    <none>   8m51s   v1.15.2

# 查看日志
tail -fn 200 /data/logs/kubernetes/kube-kubelet/kubelet.stdout.log

# 失败情况，原因还未找到
[root@worker3 bin]# kubectl get nodes
No resources found.
[root@worker3 bin]# systemctl status kubelet
Unit kubelet.service could not be found.

# ROlES添加标签，设定节点角色，可同时加两个标签
[root@hdss7-21 cert]# kubectl label node hdss7-21.host.com node-role.kubernetes.io/master=
[root@hdss7-21 cert]# kubectl label node hdss7-21.host.com node-role.kubernetes.io/node=

[root@hdss7-22 ~]# kubectl get nodes                               
NAME                STATUS   ROLES         AGE   VERSION
hdss7-21.host.com   Ready    master,node   15h   v1.15.2
hdss7-22.host.com   Ready    master,node   12m   v1.15.2
```

![image-20200811075205028](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811075205028.png)

## kube-proxy

* 连接pod网络和集群网络

* 集群规划

  ```shell
  HDSS7-21.host.com			kube-proxy		192.168.0.21	
  HDSS7-22.host.com			kube-proxy		192.168.0.22
  ```

* 运维主机HDSS7-200.host.com

  * 签发kube-proxy证书

    ```shell
    # 签发生成证书签名请求（CSR）的JSON配置文件
    [root@hdss7-200 certs]# vi /opt/certs/kube-proxy-csr.json
    {
        "CN": "system:kube-proxy",
        "key": {
            "algo": "rsa",
            "size": 2048
        },
        "names": [
            {
                "C": "CN",
                "ST": "beijing",
                "L": "beijing",
                "O": "od",
                "OU": "ops"
            }
        ]
    }
    
    # 生成证书
    [root@hdss7-200 certs]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client kube-proxy-csr.json |cfssl-json -bare kube-proxy-client
    [root@hdss7-200 certs]# ll
    -rw-r--r-- 1 root root 1005 12月 12 10:23 kube-proxy-client.csr
    -rw------- 1 root root 1679 12月 12 10:23 kube-proxy-client-key.pem
    -rw-r--r-- 1 root root 1375 12月 12 10:23 kube-proxy-client.pem
    -rw-r--r-- 1 root root  267 12月 12 10:22 kube-proxy-csr.json
    ```

* HDSS7-21.host.com

  ```shell
  # 分发证书，将证书拷贝到node节点，注意私钥文件属性600
  # hdss7-21、hdss7-21 都要拷贝
  [root@hdss7-21 ~]# cd /opt/kubernetes/server/bin/cert/
  [root@hdss7-21 cert]# scp hdss7-200:/opt/certs/kube-proxy-client-key.pem .
  [root@hdss7-21 cert]# scp hdss7-200:/opt/certs/kube-proxy-client.pem .
  
  # 在conf文件夹下创建配置 -- 只做一次，然后将kube-proxy.kubeconfig拷贝至各个node节点
  [root@hdss7-21 cert]# cd /opt/kubernetes/server/bin/conf
  # --server=https://192.168.0.10:7443 此IP地址是keeplive的VIP地址，注意修改
  [root@hdss7-21 conf]# kubectl config set-cluster myk8s \
    --certificate-authority=/opt/kubernetes/server/bin/cert/ca.pem \
    --embed-certs=true \
    --server=https://192.168.0.10:7443 \
    --kubeconfig=kube-proxy.kubeconfig
  
  [root@hdss7-21 conf]# ls
  audit.yaml  k8s-node.yaml  kubelet.kubeconfig  kube-proxy.kubeconfig
  
  [root@hdss7-21 conf]# kubectl config set-credentials kube-proxy \
    --client-certificate=/opt/kubernetes/server/bin/cert/kube-proxy-client.pem \
    --client-key=/opt/kubernetes/server/bin/cert/kube-proxy-client-key.pem \
    --embed-certs=true \
    --kubeconfig=kube-proxy.kubeconfig
  
  [root@hdss7-21 conf]# kubectl config set-context myk8s-context \
    --cluster=myk8s \
    --user=kube-proxy \
    --kubeconfig=kube-proxy.kubeconfig
  
  [root@hdss7-21 conf]# kubectl config use-context myk8s-context --kubeconfig=kube-proxy.kubeconfig
  
   scp /opt/kubernetes/server/bin/conf/kube-proxy.kubeconfig root@192.168.0.22:/opt/kubernetes/server/bin/conf/
  # 第一台node节点部署完成后，将生成的配置文件拷贝至各个Node节点
  [root@hdss7-22 cert]# cd /opt/kubernetes/server/bin/conf
  [root@hdss7-22 conf]# scp hdss7-21:/opt/kubernetes/server/bin/conf/kube-proxy.kubeconfig .
  ```

* HDSS7-21.host.com、HDSS7-22.host.com

```shell
# 加载ipvs模块	-- 脚本需要设置成开启自动运行
[root@hdss7-21 conf]# vi /root/ipvs.sh
#!/bin/bash
ipvs_mods_dir="/usr/lib/modules/$(uname -r)/kernel/net/netfilter/ipvs"
for i in $(ls $ipvs_mods_dir|grep -o "^[^.]*")
do
  /sbin/modinfo -F filename $i &>/dev/null
  if [ $? -eq 0 ];then
    /sbin/modprobe $i
  fi
done
[root@hdss7-21 conf]# chmod +x /root/ipvs.sh 
# 执行脚本
[root@hdss7-21 conf]# /root/ipvs.sh 
# 查看内核是否加载ipvs模块
[root@hdss7-21 conf]# lsmod | grep ip_vs

# 设置开机自动启动	
[root@hdss7-21 ~]# vi /etc/rc.d/rc.local
/root/ipvs.sh

# 暂时忽略
# 开启开机自启动脚本功能  -- 详见本文件夹内 开启开机自启动脚本文件
[root@hdss7-21 ~]# chmod +x /etc/rc.d/rc.local
[root@hdss7-21 ~]# mkdir -p /usr/lib/system/system/
[root@hdss7-21 ~]# vim /usr/lib/system/system/rc-local.service
[Install]
WantedBy=multi-user.target
[root@hdss7-21 ~]# ln -s '/lib/systemd/system/rc-local.service' '/etc/systemd/system/multi-user.target.wants/rc-local.service'
# 开启 rc-local.service 服务：
[root@hdss7-21 ~]# systemctl start rc-loacl.service
[root@hdss7-21 ~]# systemctl enable rc-local.service

# 创建kube-proxy启动脚本
[root@hdss7-21 ~]# vi /opt/kubernetes/server/bin/kube-proxy.sh
#!/bin/sh
./kube-proxy \
  --cluster-cidr 172.7.0.0/16 \
  --hostname-override hdss7-21.host.com \          # hdss7-22.host.com
  --proxy-mode=ipvs \
  --ipvs-scheduler=nq \
  --kubeconfig ./conf/kube-proxy.kubeconfig

[root@hdss7-21 ~]# chmod +x /opt/kubernetes/server/bin/kube-proxy.sh
[root@hdss7-21 ~]# mkdir -p /data/logs/kubernetes/kube-proxy
[root@hdss7-21 ~]# vi /etc/supervisord.d/kube-proxy.ini
[program:kube-proxy-7-21]                    # 根据实际情况修改 7-21、7-22
command=sh /opt/kubernetes/server/bin/kube-proxy.sh                     ; the program (relative uses PATH, can take args)
numprocs=1                                                           ; number of processes copies to start (def 1)
directory=/opt/kubernetes/server/bin                                 ; directory to cwd to before exec (def no cwd)
autostart=true                                                       ; start at supervisord start (default: true)
autorestart=true                                                     ; retstart at unexpected quit (default: true)
startsecs=30                                                         ; number of secs prog must stay running (def. 1)
startretries=3                                                       ; max # of serial start failures (default 3)
exitcodes=0,2                                                        ; 'expected' exit codes for process (default 0,2)
stopsignal=QUIT                                                      ; signal used to kill process (default TERM)
stopwaitsecs=10                                                      ; max num secs to wait b4 SIGKILL (default 10)
user=root                                                            ; setuid to this UNIX account to run the program
redirect_stderr=true                                                 ; redirect proc stderr to stdout (default false)
stdout_logfile=/data/logs/kubernetes/kube-proxy/proxy.stdout.log     ; stderr log path, NONE for none; default AUTO
stdout_logfile_maxbytes=64MB                                         ; max # logfile bytes b4 rotation (default 50MB)
stdout_logfile_backups=4                                             ; # of stdout logfile backups (default 10)
stdout_capture_maxbytes=1MB                                          ; number of bytes in 'capturemode' (default 0)
stdout_events_enabled=false                                          ; emit events on stdout writes (default false)

[root@hdss7-21 ~]# supervisorctl update
[root@hdss7-21 ~]# supervisorctl status
kube-proxy-7-21                  RUNNING   pid 6873, uptime 0:28:15
[root@hdss7-22 ~]# netstat -luntp |grep kube-proxy
tcp        0      0 127.0.0.1:10249         0.0.0.0:*               LISTEN      7310/./kube-proxy   
tcp6       0      0 :::10256                :::*                    LISTEN      7310/./kube-proxy  
# 查看日志
tail -fn 200 /data/logs/kubernetes/kube-proxy/proxy.stdout.log

# 查看ipvs是否生效
[root@hdss7-21 ~]# yum install -y ipvsadm	# 只安装，不启动
[root@hdss7-21 ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.0.1:443 nq
  -> 10.4.7.21:6443          Masq    1      0          0         
  -> 10.4.7.22:6443          Masq    1      0          0  
  
# 注意：kube-proxy集群各主机启动脚本略有不同，部署其他节点注意修改
[root@hdss7-21 ~]# cat /data/logs/kubernetes/kube-proxy/proxy.stdout.log 
```

![image-20200811081202303](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811081202303.png)

![image-20200811081218729](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811081218729.png)

![image-20200811081909475](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811081909475.png)

![image-20200811082114829](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811082114829.png)

![image-20200811082051435](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811082051435.png)

# 完成部署并验证集群

* 在任意一个运算节点，创建一个资源配置清单
  * 这里选择DHSS7-21.host.com主机

```shell
[root@hdss7-21 ~]# vi /root/nginx-ds.yaml
apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
  name: nginx-ds
spec:
  template:
    metadata:
      labels:
        app: nginx-ds
    spec:
      containers:
      - name: my-nginx
        image: harbor.od.com/public/nginx:v1.7.9
        ports:
        - containerPort: 80
        
# 测试完删除
[root@hdss7-21 ~]# kubectl create -f nginx-ds.yaml 
daemonset.extensions/nginx-ds created

[root@hdss7-21 ~]# kubectl get pods -o wide
NAME             READY   STATUS    RESTARTS   AGE   IP           NODE                NOMINATED NODE   READINESS GATES
nginx-ds-72zm5   1/1     Running   0          86s   172.7.21.2   hdss7-21.host.com   <none>           <none>
nginx-ds-cb7ct   1/1     Running   0          86s   172.7.22.2   hdss7-22.host.com   <none>           <none>

[root@hdss7-21 ~]curl 172.7.21.2
# 有内容
[root@hdss7-21 ~]curl 172.7.22.2
# 没有内容  跨宿主主机容器还不能通信

[root@hdss7-21 ~]# kubectl delete -f nginx-ds.yaml 
[root@hdss7-21 ~]# kubectl get cs
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-0               Healthy   {"health": "true"}   
etcd-2               Healthy   {"health": "true"}   
etcd-1               Healthy   {"health": "true"}      
```

![image-20200811083031036](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811083031036.png)

# 资源需求说明

```shell
实现一整套的K8S生态的搭建，并实战交付一套dubbo(java)微服务，我们要一步步实现以下工呢
1.持续集成
2.配置中心
3.监控意向图
4.日志收集分析系统
5.自动化运维平台（最终实现基于K8S的开源Paas平台）

资源要求
2c/2g/50g x 3 + 4c/4g/50g x 2
```



![image-20200811083117321](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20200811083117321.png)

# 开启开机启动

```shell
# 开机启动脚本不执行了：
原因：在centos7上面默认是使用systemd的，所以rc.local这个文件应该也是通过systemd的service启动的，
	service是通过ExecStart=/etc/rc.d/rc.local start来启动的，所以这个文件需要有执行权限。
chmod +x /etc/rc.d/rc.local

# 开启 rc-local.service 服务：
systemctl enable rc-local.service
systemctl start rc-local.service

# Systemctl enable rc-loacl.service 不成功？
systemctl enable rc-local.service
The unit files have no [Install] section. They are not meant to be enabled
using systemctl.
Possible reasons for having this kind of units are:
1) A unit may be statically enabled by being symlinked from another unit's
.wants/ or .requires/ directory.
2) A unit's purpose may be to act as a helper for some other unit which has
a requirement dependency on it.
3) A unit may be started when needed via activation (socket, path, timer,
D-Bus, udev, scripted systemctl call, ...).
# 提示启动service里面没有install这节的内容。那就给它通过多用户的target启动就可以了。
vim /usr/lib/system/system/rc-local.service
[Install]
WantedBy=multi-user.target
# 然后再次enable启动服务：
systemctl enable rc-local.service
ln -s '/lib/systemd/system/rc-local.service' '/etc/systemd/system/multi-user.target.wants/rc-local.service'
```



