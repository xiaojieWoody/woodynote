# 基础

* ==JVM常见的调优参数包括：==

  1. ==-Xmx：指定java程序的最大堆内存==, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存
  2. ==-Xms：指定最小堆内存==, 通常设置成跟最大堆内存一样，减少GC
  3. ==-Xss：指定线程的最大栈空间, 此参数决定了java函数调用的深度==, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)，不是OOM
  4. -XX:NewSize=value：设置新生代大小。整个堆大小=年轻代大小 + 年老代大小。官方推荐配置为整个堆的3/8
  5. -XX:NewRatio=n：老年代与新生代的比值，默认为3
  6. -XX:PermSize：指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定
  7. -XX:MaxPermSize：指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小
  8. -XX:SurvivorRatio=n：Eden区与Survivor区的大小比值，8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)
* Serial 与 Parallel GC之间的不同之处？
  - 在GC执行的时候都会引起 stop-the-world。
  - 它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行
* java内存溢出问题你们是怎么排查的
  - 抓取对应pid的dump文件
    - `kill -3 <pid>`
    - 当使用 `kill -3` 生成 dump 文件时，dump 文件会被输出到标准错误流。假设应用运行在 tomcat 上，dump 内容将被发送到`<TOMCAT_HOME>/logs/catalina.out`文件里
  - 然后用 Profiler 工具
* JVM优化Java代码时都做了什么?
  - JVM在对代码执行的优化可分为运行时(runtime)优化和即时编译器(JIT)优化
    - 运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制(如偏斜锁)、内存分配机制(如TLAB)等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存(inline cache，用于优化虚方法调用的动态绑定)
    - JVM的即时编译器优化是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析
* ==解释 Java 堆空间及 GC==
  - 当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从堆空间中分配内存。
  - GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配
* 能保证 GC 执行吗

  - 不能，虽然可以调用 `System.gc()` 或者 `Runtime.gc()`，但是没有办法保证 GC 的执行
* 怎么获取 Java 程序使用的内存？堆使用的百分比
  - 可通过`java.lang.Runtime` 类中与内存相关方法来获取最大堆内存、总内存及剩余内存。
  - `Runtime.maxMemory()` ：java虚拟机能从操作系统那里挖到的最大的内存，以字节为单位，如果在运行`java`程序的时候，没有添加-Xmx参数，那么就是64兆
  - `Runtime.totalMemory() `：java虚拟机现在已经从操作系统那里挖过来的内存大小
  - `Runtime.freeMemory()` ：挖过来而又没有用上的内存
    - `Runtime.getRuntime().freeMemory()`
* ==Java 中堆和栈有什么区别==
  - JVM 中堆和栈属于不同的内存区域，使用目的也不同。
    - 栈常用于保存方法帧和局部变量，而对象总是在堆上分配。
    - 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享
* ==谈谈你的GC调优思路?==

  - 调优的目标是什么?从性能的角度看，通常关注三个方面，==内存占用(footprint)、延时(latency)和吞吐量==(throughput)，大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度
  - 理解应用需求和问题，确定调优目标
    - 如应用服务出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望GC暂停尽量控制在200ms以内，并且保证一定标准的吞吐量 
  - 掌握JVM和GC的状态，定位具体的问题，确定真的有GC调优的必要
    - 通过jstat等工具查看GC等相关状态，可以开启GC日志，或者是利用操作系统提供的诊断工具等
    - 例如，通过追踪GC日志，就可以查找是不是GC在特定时间发生了长时间的暂停，进而导致了应用响应不及时 
  - 判断选择的GC类型是否符合应用特征
    - 如果是，具体问题表现在哪里，是Minor GC过长，还是Mixed GC等出现异常停顿情况;如果不是，考虑切换到什么类型，如CMS和G1都是更侧重于低延迟的GC选项
  - 通过分析确定具体调整的参数或者软硬件配置
    - 验证是否达到调优目标，如果达到目标，即可以考虑结束调优;否则，重复完成分析、调整、验证这个过程 

# Java平台

* ==Java本身是一种面向对象的语言，最显著的特性有两个方面：==
  * ==跨平台：书写一次，到处运行==
    * ==Java分为编译期和运行时，编译Java源码生成“.class”字节码文件，在运行时，JVM会通过类加载器(Class-Loader)加载字节码，将字节码文件转换成机器能够识别的机器码，屏蔽了操作系统和硬件的细节==
  * ==内存管理：内存的分配和回收，通过垃圾收集器回收分配内存==
* JRE：Java运行环境，包含了JVM和Java类库，以及一些模块
* JDK：包括JRE、编译器、各种诊断工具等
* Java是解释执行，不太准确
  * Java源代码先通过Javac编译成为字节码，然后在运行时通过 Java虚拟机内嵌的解释器将字节码转换成为最终的机器码
  * 常见的JVM，如Hotspot JVM，提供了JIT动态编译器能够在运行时将热点代码编译成机器码，就属于编译执行，而不是解释执行

# JVM原理

* ==JVM本身是介于Java编译器和操作系统之间的程序，提供了一个无视操作系统和硬件平台的Java运行环境==
  * ==能将字节码转换成机器能够识别的机器码==
  * ==提供内存管理==

## Java内存区域分配

* 按线程是否共享分为以下区域

  * ==所有线程共享的数据区：==

    1. ==方法区==（JVM规范中的一部分，不是实际的实现）:==存储元数据，如类结构信息、字段==及对应的运行时常量池、方法代码等（JIT编译后的代码）

    * ==Java7时称为永久代，Java8将永久代移除，同时增加了元空间==
      * Java8时由元空间实现
        * ==元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性==

      * 没有要求使用垃圾回收，因为回收效率太低
        * 回收废弃常量（没有被引用）和无用的类（所有实例都被回收、加载该类的ClassLoader被回收、对应的Class对象没有在任何地方被引用，无法通过反射访问该类的方法）

      * ==运行时常量池：存放编译器生成的各种字面量和符号引用，在类加载后放到运行时常量池中==

    2. ==堆区：最大的一块区域，是大部分对象、数组分配内存的区域==

    * 通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，但Oracle Hotspot JVM中并未这么做
    * 对象实例都是分配在堆上

  * ==每个线程都会有一块私有的数据区：==

    1. ==虚拟机栈：内部保存Java方法被调用时生成的栈帧==
       * ==用于存储局部变量表（如基本数据类型和对象引用）、方法正常退出或者异常退出的定义、方法返回地址等==。
       * 正常调用完成后恢复调用者的局部变量表、操作数栈、递增程序计数器来跳过刚才执行的指令，或抛出异常不将返回值返回给调用者
    2. ==本地方法栈：功能与虚拟机栈相同，为native方法服务==
    3. ==程序计数器：当前线程所执行的字节码的行号指示器==
       * 唯一一个没有内存溢出的区域。即不会发生OutOfMemoryError
         * 堆内存不足是最常见的OOM原因之一：内存泄漏问题、堆的大小不合理
         * Java虚拟机栈和本地方法栈：程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈
         * 永久代的大小是有限的，并且JVM对永久代垃圾回收非常不积极，不断添加新类型导致
         * 元数据区、直接内存不足
       * 在虚拟机的概念模型里，字节码解释器工作时就是==通过改变这个计数器的值来选取下一条需要执行的字节码指令==
         * ==分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成==
           * ==为了线程切换后能恢复到正确地执行位置，每条线程都需要有一个独立的程序计数器==

* 以HotSpot虚拟机实现为例，==Java8中内存区域==如下：

  - ==虚拟机数据区==
    - 共享：
      - 堆
    - 不共享：
      - 虚拟机栈、本地方法栈、程序计数器
  - ==本地内存区域==
    - 共享：
      - ==元空间：方法区的实现==
        - Java7以及之前是使用的永久代来实现方法区，大小是在启动时固定的
        - Java8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性
          - 元空间存储JIT即时编译后的native代码
      - 直接内存：非Java标准，是JVM以外的本地内存

* ==运行时常量池：Java7之后运行时常量池从方法区移到堆区==，为Java8移除永久代的做好准备

## Java对象不都是分配在堆上

- 逃逸分析

  - ==逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到==
    - 后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收
    - 由于其被其它变量引用，由于无法回收，即称为逃逸。
- 逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁

## 类加载机制

* 虚拟机的类加载机制

  * ==虚拟机把描述类的数据从`Class`文件加载到内存，并对数据进行验证、准备、解析和初始化，最终形成可以被虚拟机直接使用的`Java`类型==

* 类型的加载、连接和初始化过程都是在程序运行期间完成的

  * 提供高度的灵活性，天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接

* 加载过程

  1. 加载：==读取来自不同数据源（`Jar`文件、`class`文件、网络）的字节码数据到`JVM`中并转换成`JVM`认可的数据结构，即`Class`对象==
  2. 验证：==验证字节流信息符合当前虚拟机规范，防止被篡改过的字节码危害JVM安全==
  3. 准备：==为类或接口中的静态变量分配内存并设置初始值==
  4. 解析：==将常量池中的符号引用替换为直接引用==

     * ==符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针==

     * 解析阶段在某些情况下可以在初始化阶段之后再开始——为了支持Java语言的运行时绑定
  5. 初始化：==静态变量赋值、执行静态语句块、执行类构造器==

* `ClassLoader`

  - ==ClassLoader用来动态加载`class`⽂件到内存当中==
    - 程序在启动的时候，并不会一次性加载程序所要用的所有`class`文件，而是根据程序的需要，通过Java的类加载机制(`ClassLoader`)来动态加载某个`class`文件到内存当中的，从而只有`class`⽂件被载⼊到了内存之后，才能被其它`class`所引用

* ==`ClassLoader`和`Class.forName`的区别==

  - ==都是将.class文件加载到jvm中==
  - ==ClassLoader只是将.class文件加载到jvm中，不会对类进行初始化，只有在`newInstance`时才初始化==
  - ==Class.forName还会对类进行初始化==
  - 都是用来对类（类的全限定名称）进行加载，将.class文件加载到jvm中，但是`ClassLoader`不会对类进行初始化
    - `Class.forName`还会对类进行解释，执行其`static`块（静态代码块和静态成员变量被静态方法赋值），包括加载-连接（验证、准备、解析）-初始化
    - `ClassLoader`只有在`newInstance`时才执行`static`块，只是加载，`newInstance`时才连接、初始化

* 类加载器

  - ==启动类加载器==
    - 用C++语言实现，是虚拟机自身的一部分，它负责加载`<JAVA_HOME>/lib`路径下的==核心类库==，无法被Java程序直接引用 
  - ==扩展类加载器==
    - 用Java语言实现，它负责加载`<JAVA_HOME>/lib/ext`==目录==下或者由系统变量`-Djava.ext.dir`指定位路径中的类库，开发者可以直接使用
  - ==应用类加载器==
    - 用Java语言实现，它==负责加载系统类路径`ClassPath`指定路径下的类库==，开发者可以直接使用

* ==JVM虚拟机认为，两个类相等的条件是==

  - 来源于同一个`Class`文件且被同一个类加载器加载

* ==自定义类加载器==

  - 如果不想打破双亲委派模型，那么继承`ClassLoader`类只需要重写`findClass`方法即可
  - 如果想打破双亲委派模型，那么继承`ClassLoader`类重写`loadClass`和`findClass`方法
    - 默认的`loadClass`方法是实现了双亲委派机制的逻辑

* ==双亲委派==

  - 如果父加载器可以完成类加载任务，就成功返回，否则，子加载器尝试自己去加载
  - 优点
    - 避免类的重复加载，防止恶意覆盖Java核心API

* 三次大型破坏双亲委派模式的事件：

  1. ==自定义类加载器，继承`ClassLoader`，重写`loadClass`和`findClass`方法==

     * 实现类似进程内隔离，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰 

     * 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统

     * 需要自己操纵字节码，动态修改或者生成类型

       ```java
       public class CustomClassLoader extends ClassLoader {
           @Override
           public Class findClass(String name) throws ClassNotFoundException {
               byte[] b = loadClassFromFile(name);
             	//二进制信息到Class对象的转换
               return defineClass(name, b, 0, b.length);
           }
        
           private byte[] loadClassFromFile(String fileName)  {
               InputStream inputStream = getClass().getClassLoader().getResourceAsStream(
                       fileName.replace('.', File.separatorChar) + ".class");
               byte[] buffer;
               ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
               int nextValue = 0;
               try {
                   while ( (nextValue = inputStream.read()) != -1 ) {
                       byteStream.write(nextValue);
                   }
               } catch (IOException e) {
                   e.printStackTrace();
               }
               buffer = byteStream.toByteArray();
               return buffer;
           }
       }
       ```

  2. ==如果基础类要调回用户的代码，如`JNDI/JDBC`需要调用`ClassPath`下的自己的代码来进行资源管理==

     * 这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器

  3. 为了==实现代码热替换==，OSGi是为了实现自己的类加载逻辑，用平级查找的逻辑替换掉了向下传递的逻辑。但其实可以不破坏双亲委派逻辑而是自定义类加载器来达到代码热替换

* ==立即初始化类的情况==

  - ==创建类的实例时，如new==
    - 但是通过数组定义来引用类，不会触发此类的初始化`SuperClass[] sca = new SuperClass[10]`
  - ==初始化一个类时，如果其父类还没初始化，则需先触发其父类初始化==
    - 接口有所不同，只有在真正使用到父接口的时候才会初始化
  - ==使用反射⽅式来强制创建某个类或接口对应的java.lang.Class对象==
  - 当虚拟机启动时会初始化一个要执行的主类（包括main方法的那个类）
  - ==调用某个类的静态⽅法==
  - ==通过子类引用父类的静态字段，不会导致子类的初始化，只会触发父类的初始化==
    - 对于静态字段，只有直接定义这个字段的类才会被初始化
* 有哪些方法可以在运行时动态生成一个Java类?

  - 编写Java代码，调用javac编译成class文件，然后通过类加载机制载入JVM，就成为应用运行时可以使用的Java类
    - 获取符合JVM规范的字节码，不管它是如何生成的，都可以被JVM加载
    - 可以利用Java字节码操纵工具和类库来实现生成字节码，然后交给类加载器去加载
      - asm、cglib
      - 字节码操纵技术，除了动态代理，还可以应用在什么地方?
        - 各种Mock框架、ORM框架、IOC容器、部分Profiler工具或者运行时诊断工具等

## 内存分配（堆上的内存分配）

* 堆
  * ==新生代==
    * 进入条件
      * ==大部分对象创建和销毁的区域==
    * ==Eden==
      * ==对象初始分配的区域==
      * TLAB（Thread-local allocation buffer）
        * ==JVM会为每个线程在Eden Space中开辟一小块线程私有的区域TLAB==
          * 在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可
        * ==在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，适合优先分配在TLAB上，并且线程私有，没有锁开销，分配多个小对象比分配一个大对象效率高==
    * ==两个Survivor==
      * ==被用来放置从Minor GC中保留下来的对象==
      * 新生代中98%的对象是朝生夕死
      * ==回收时，将Eden区和一个Survivor中还存活的对象一次性复制到另外一块Survivor空间上，然后清理掉Eden和刚才使用过的Survivor区==
        * 防止内存的碎片化，并进一步清理无用对象
    * 8:1:1，会在S1多待一段时间而不是立马分到老年代
      - 对象最好不要进入老年代——Major GC，比Minor GC慢10倍
      - 对象最好是在新生代被回收掉，对象生命周期不一样——分代
  * ==老年代==
    * 进入条件（该区域中对象存活率高）
      * ==新生代垃圾回收一次，存活对象的年龄就加1，当年龄大于预设值就进入老年代==
      * ==大对象==，-XX:PretenureSizeThreshold 大于这个参数的对象直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制
      * ==如果Survivor空间无法容纳新生代中Minor GC之后还存活的对象==
      * ==如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象进入老年代==
    * 老年代的垃圾回收（又称Major GC）通常使用==“标记-清理”==或==“标记-整理”==算法
    * 整堆包括新生代和老年代的垃圾回收称为Full GC
      * HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代

* ==内存分配策略==
  - 对象优先在 Eden 分配
  - 大对象直接进入老年代
  - 长期存活的对象将进入老年代

## GC回收机制

* ==当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化==

* 当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法。

  - ==“分代回收”是基于：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率==

* Java 中的垃圾回收一般是在 Java 堆中进行，因为堆中几乎存放了 Java 中所有的对象实例

  - ==引用类型==
    - 不同场景使用不同的引用类型，使得对象能够合理的被JVM的垃圾回收机制回收，避免OOM
    - 强引用：如“Object obj = new Object（）”，==只要还存在，垃圾收集器就永远不会回收掉被引用的对象==。赋值为null时可以被回收（GC Root不可达时被回收）
    - 软引用：==内存不足时被GC回收==
    - 弱引用：==只要GC就回收==
    - 虚引用：==无法通过虚引用来取得一个对象实例，唯一目的是希望该对象被回收时能收到一个系统通知==

* 可回收对象

  - 对于对象实例收集，主要是两种基本算法，引用计数和可达性分析
    - ==引用计数算法==
      - 为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收
      - Java并没有选择引用计数，因为很难处理==循环引用关系==
    - ==可达性分析==
      - Java选择的
      - ==如果一个对象和GC Roots之间不可达，即不存在引用链条，那么即可认为是可回收对象==
        - ==以一系列的GC Roots的对象作为起点向下搜索走过的路径称为引用链==
        - JVM会把==虚拟机栈和本地方法栈中JNI正在引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象==，作为GC Roots

* ==彻底死亡条件==：

  - 条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。
  - 条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），就真的被回收
    - finalize()方法是对象逃脱死亡命运的最后一次机会
      - 任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()不会被再次执行
      - 虚拟机会触发finalize()方法，但并不承诺会等待它运行结束
        - 如果执行缓慢或者发生死循环，可能导致整个内存回收系统崩溃

* ==如何回收==

  - ==新生代==

    - Minor GC，当新生代Eden区空间不足以继续分配对象，发起Minor GC
    - 因为每次GC都有大批对象死去，所以采用复制成本低且无碎片的复制算法
    - ==复制算法==：
      - 将可用内存按容量划分为Eden、from survivor、to survivor，默认8:1:1
        - 新生代中的对象98%是"朝生夕死"
      - ==每次使用Eden区和一块Survivor区，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor区，这样没有内存碎片==
    - ==空间分配担保==
      - 虚拟机在进行Minor GC之前会检查老年代的最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC是安全的，否则虚拟机会查看是否设置了允许担保失败（HandlePromotionFailure），如果允许，则会继续检查老年代的最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC，如果小于或者没设置允许担保失败，则进行一次Full GC

  - ==老年代==

    - Major GC
    - 因为存活率高、没有分配担保空间，如果执行较多的复制操作，效率将会变低，所以使用“标记-清理”或者“标记-整理”算法
    - ==标记-清除==
      - 首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象
      - 会产生大量碎片，导致无法分配大对象从而导致频繁GC。
    - ==标记-整理==
      - 首先标记出所有需要回收的对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

  - ==Full GC条件==

    - Full GC：新生代+老年代，垃圾回收器最终目的是减少Full GC

    1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
    2. 老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）
    3. 方法区空间不足

## 垃圾收集器

* 只负责回收堆内存中的对象
  - 程序无法精确控制垃圾回收的运行，其会在合适的时候进⾏
  - 回收任何对象之前，总会先调用它的`finalize()`方法(不一定会被执行) `=>`可导致该对象重新复活
  - 可达状态 可恢复状态 不可达状态
  - `System.gc()` 、`Runtime.getRuntime().gc()`
* `Serial GC`
  - ==最古老的收集器，只使用一个线程去回收，必须暂停其他所有的工作线程直到收集结束，可能会产生较长的停顿STW。对于单个CPU来说没有线程交互的开销，简单高效==
  - ==新生代使用复制算法、老年代使用标记-整理算法==
  - 参数：`-XX:+UseSerialGC`，默认开启`-XX:+UseSerialOldGC`
* `ParNew GC`
  - ==实际是Serial GC的多线程版本==，最常见的应用场景是配合老年代的CMS GC工作
  - `-XX:+UseConcMarkSweepGC -XX:+UseParNewGC`
* `Parrallel GC`
  - ==并行的多线程收集器，目标是达到一个可控制的吞吐量==
    - 可自适应调整参数以提供最合适的停顿时间或者最大吞吐量
  - ==特点是新生代和老年代GC都是并行进行的==
  - ==新生代复制算法、老年代标记-整理算法==
  - 参数：`-XX:+UseParallelGC`，默认开启`-XX:+UseParallelOldGC`
* `CMS GC`
  - Concurrent Mark Sweep，==基于标记-清除算法，并发收集，目标是尽量减少停顿时间==
    - ==存在着内存碎片化问题，长时间运行等情况下容易发生full GC，导致恶劣的停顿==
    - ==并发会占用更多CPU资源，并和用户线程争抢==
  - 参数：`-XX:+UseConcMarkSweepGC`，默认开启`-XX:+UseParNewGC`
* `G1 GC`
  - Garbage-First，==兼顾吞吐量和停顿时间==
    - 并发与并行、分代收集、空间整合、可预测的停顿
    - Oracle JDK 9以后的默认GC选项，可以直观的设定停顿时间的目标
  - ==将堆划分为多个大小固定的独立区域，根据每次允许的收集时间优先回收垃圾最多的区域，使用`标记-整理`算法==
    - ==虽然保留新生代和老年代的概念，但不再是物理隔离的了，都是一部分独立区域的集合==
  - 参数：`-XX:+UseG1GC`
* ==如何选择垃圾收集器==
  1. 需要停顿时间能超过1秒且想要一个可控的吞吐量时，使用并行收集器
  2. 如果停顿时间重要且不超过1秒，使用并发收集器
  3. 如果内存小于100M，使用串行或者JVM自己选
  4. 如果是单核，且没有系统停顿要求，使用串行或者JVM自己选
* Stop The World，STW
  - ==是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起，Java中一种全局暂停现象==
  - ==STW总会发生，不管是新生代还是老年代，只能尽量去减少STW的时间==
    - 比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿
  - 那么为什么一定要STW？
    - 因为在定位堆中的对象时JVM会记录下对所有对象的引用
    - 如果在定位对象过程中，有新的对象被分配或刚记录下的对象突然变得无法访问，就会导致一些问题
      - 比如部分对象无法被回收，更严重的是如果GC期间分配的一个GC Root对象引用了准备被回收的对象，那么该对象就会被错误地回收。

# 堆中对象

## 创建

* 普通Java对象，不包括数组和Class对象的创建

* ==虚拟机遇到一条new指令时：==

  1. ==检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程==

  2. ==类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可完全确定==

     分配方式：

     - 堆内存是绝对规整——指针碰撞
       - 用过的在一边，没有过的在另一边，中间的指针向空闲空间挪动一段与对象大小相等的距离
     - 堆内存不规整——空闲列表
       - 已用和空闲内存空间相互交错，虚拟机必须维护一个列表来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上记录
     - 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

  * 并发线程安全问题：
    * 对分配内存空间的动作进行同步处理
      * 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定

  3. 内存分配完成后，==JVM需将分配到内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用==
  4. ==JVM对对象进行必要的设置，例如这个对象是哪个类的实例==、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中
  5. ==执行`<init>`方法，把对象按照程序员的意愿进行初始化==

## 对象内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为==3块区域==：

* ==对象头==
  * 第一部分用于==存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID==、偏向时间戳等
  * 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来==确定这个对象是哪个类的实例==。
    * 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小
* ==实例数据==
  * 是对象真正存储的有效信息，也是程序代码中所定义的==各种类型的字段内容==
    - 无论是从父类继承下来，还是在子类中定义的，都需要记录起来
* ==对齐填充==
  - ==不是必然存在的，仅仅起者占位符的作用==
    - 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍（==对象的大小必须是8字节的整数倍==），而对象头部分正好是8字节的倍数（1倍或者2倍），因此，==当对象实例数据部分没有对齐时，就需要通过对齐填充来补全==

## 访问定位

* ==Java 程序需要通过栈上的reference数据来操作堆上的具体对象==

* 对象访问方式：

  1. ==使用句柄==

     * Java堆中将会划分出一块内存来作为句柄池，==reference（栈的本地变量表中）中存储的就是对象的句柄地址，而句柄中包含了对象实例数据（堆）与类型数据（方法区）各自的具体地址信息==
     * 好处：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改

  2. ==直接指针==

     * ==reference中存储的直接就是对象的地址==

       好处：速度更快，节省了一次指针定位的时间开销

